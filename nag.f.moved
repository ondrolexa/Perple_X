      SUBROUTINE D01AHY(A,B,RESULT,K,EPSIL,NPTS,ICHECK,F,AMAXL,AMAXR,R1,
     *                  IT)
C     MARK 8 RELEASE. NAG COPYRIGHT 1979.
C     MARK 11.5(F77) REVISED. (SEPT 1985.)
C
C     CONTROLS BASIC ALGORITHM D01AHX, APPLYING A FURTHER RANDOM
C     TRANSFORMATION IF CONVERGENCE WAS ACHIEVED AS A RESULT OF THE
C     E-ALGORITHM TO IMPROVE RELIABILITY
C
C     .. Scalar Arguments ..
      DOUBLE PRECISION  A, AMAXL, AMAXR, B, EPSIL, R1
      INTEGER           ICHECK, IT, K, NPTS
C     .. Array Arguments ..
      DOUBLE PRECISION  RESULT(8)
C     .. Function Arguments ..
      DOUBLE PRECISION  F
      EXTERNAL          F
C     .. Scalars in Common ..
      DOUBLE PRECISION  ALP, AV, FZERO
      INTEGER           IR, NT
C     .. Arrays in Common ..
      DOUBLE PRECISION  FUNCTM(127), FUNCTP(127)
C     .. Local Scalars ..
      DOUBLE PRECISION  ALAST, ERR, XDUM
      INTEGER           IQ, NF
C     .. External Functions ..
      DOUBLE PRECISION  D01AHU, G05CAF
      EXTERNAL          D01AHU, G05CAF
C     .. External Subroutines ..
      EXTERNAL          D01AHV, D01AHX
C     .. Intrinsic Functions ..
      INTRINSIC         ABS
C     .. Common blocks ..
      COMMON            /BD01AH/FUNCTP, FUNCTM, FZERO
      COMMON            /CD01AH/ALP, AV, NT, IR
C     .. Executable Statements ..
      NPTS = 0
      IR = 0
      IQ = 0
C
C     RANDOM TRANSFORMATION PARAMETER
C     USE STANDARD NAG ROUTINE G05CAF FOR RANDOM NUMBER
   20 ALP = (2.0D0*G05CAF(XDUM)-1.0D0)*0.01D0/D01AHU(B-A)
      CALL D01AHX(A,B,RESULT,K,EPSIL,NF,ICHECK,F,AMAXL,AMAXR,R1,IT)
      NPTS = NPTS + NF
      IF (ICHECK.EQ.0) GO TO 100
      IF (ICHECK.NE.4) RETURN
C
C     CONVERGED USING E-ALGORITHM
      IF (IQ.EQ.0) GO TO 60
   40 ERR = ABS(ALAST-RESULT(K))
      IF (ERR.LE.ABS(ALAST)*EPSIL) GO TO 80
      IF (K.LT.5) GO TO 120
C
C     CALCULATE VARIATION ON LEFT AND RIGHT
      CALL D01AHV(A,B,AMAXL,AMAXR)
      RETURN
C
C     CHECK RESULT
   60 IQ = 1
      ALAST = RESULT(K)
      IR = 1
      GO TO 20
   80 ICHECK = 0
      RETURN
  100 IF (IQ.EQ.0) RETURN
C
C     ICHECK = 4  INDICATES THAT A CONVERGED RESULT WAS OBTAINED
C     AFTER
C     APPLYING E- ALGORITHM.
      ICHECK = 4
      GO TO 40
  120 AMAXL = 0.0D0
      AMAXR = 0.0D0
      RETURN
      END

      DOUBLE PRECISION FUNCTION X02AMF()
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C
C     RETURNS THE 'SAFE RANGE' PARAMETER
C     I.E. THE SMALLEST POSITIVE MODEL NUMBER Z SUCH THAT
C     FOR ANY X WHICH SATISFIES X.GE.Z AND X.LE.1/Z
C     THE FOLLOWING CAN BE COMPUTED WITHOUT OVERFLOW, UNDERFLOW OR OTHER
C     ERROR
C
C        -X
C        1.0/X
C        SQRT(X)
C        LOG(X)
C        EXP(LOG(X))
C        Y**(LOG(X)/LOG(Y)) FOR ANY Y
C
      DOUBLE PRECISION X02CON
      DATA X02CON /2.22507385850721D-308 /
C     .. Executable Statements ..
      X02AMF = X02CON
      RETURN
      END

      SUBROUTINE D01AHV(A,B,AMAXL,AMAXR)
C     MARK 8 RELEASE. NAG COPYRIGHT 1979.
C     MARK 11.5(F77) REVISED. (SEPT 1985.)
C
C     CALCULATES THE RELATIVE GRADIENTS AT A AND B (RESPECTIVE SIZES
C     AMAXL AND AMAXR)
C
C     .. Scalar Arguments ..
      DOUBLE PRECISION  A, AMAXL, AMAXR, B
C     .. Scalars in Common ..
      DOUBLE PRECISION  FZERO
C     .. Arrays in Common ..
      DOUBLE PRECISION  FUNCTM(127), FUNCTP(127)
C     .. Local Scalars ..
      DOUBLE PRECISION  D1, D30, P, Q, SUM, T
      INTEGER           I, J
C     .. Local Arrays ..
      DOUBLE PRECISION  PIV(15)
C     .. Intrinsic Functions ..
      INTRINSIC         ABS
C     .. Common blocks ..
      COMMON            /BD01AH/FUNCTP, FUNCTM, FZERO
C     .. Data statements ..
C
C     5 DIGITS ARE SUFFICIENT HERE FOR PIV (31-POINT RULE NODES)
      DATA              PIV(1), PIV(2), PIV(3), PIV(4), PIV(5), PIV(6),
     *                  PIV(7), PIV(8), PIV(9), PIV(10), PIV(11),
     *                  PIV(12), PIV(13), PIV(14), PIV(15)/.99910D0,
     *                  .99383D0, .98153D0, .96049D0, .92965D0,
     *                  .88846D0, .83673D0, .77460D0, .70250D0,
     *                  .62110D0, .53132D0, .43424D0, .33114D0,
     *                  .22339D0, .11249D0/
C     .. Executable Statements ..
      SUM = 0.0D0
      DO 20 J = 1, 14
         I = J*8
         T = PIV(J) - PIV(J+1)
         P = (FUNCTM(I+8)-FUNCTM(I))/T
         Q = (FUNCTP(I)-FUNCTP(I+8))/T
         SUM = SUM + ABS(P) + ABS(Q)
   20 CONTINUE
      T = PIV(15)
      P = (-FUNCTM(120)+FZERO)/T
      Q = (-FZERO+FUNCTP(120))/T
      T = PIV(1) - PIV(2)
      D1 = (FUNCTM(16)-FUNCTM(8))/T
      D30 = (FUNCTP(8)-FUNCTP(16))/T
      SUM = SUM + ABS(P) + ABS(Q)
      AMAXL = ABS(D1)/SUM
      AMAXR = ABS(D30)/SUM
      RETURN
      END

      SUBROUTINE D01AHW(F,V,A,B,R1,VAL,IT)
C     MARK 8 RELEASE. NAG COPYRIGHT 1979.
C     MARK 11.5(F77) REVISED. (SEPT 1985.)
C
C     CALCULATES THE VALUE OF THE TRANSFORMED INTEGRAND.
C     A RANDOM TRANSFORMATION (IR NON-ZERO, AND CONTROLLED BY ALP)
C     AND POSSIBLY A SINGULARITY WEAKENING TRANSFORMATION
C     (IT NON-ZERO, AND CONTROLLED BY NT) WILL BE APPLIED.
C     WITH A POSSIBLE SINGULARITY AT ENDPOINT  R1  THE
C     TRANSFORMATION OF VARIABLE IS
C
C                X = (T-A)**(NT+1)/(B-A)**NT+A,  R1=A
C          OR    X = (T-B)**(NT+1)/(A-B)**NT+B,  R1=B
C
C     THE RANDOM TRANSFORMATION IS -
C
C                X = A*B*ALP+(1-ALP*(A+B))*T+ALP*T**2
C
C     WHERE  ALP*(B-A)  IS    RANDOM IN  (-.01,.01).
C
C     .. Scalar Arguments ..
      DOUBLE PRECISION  A, B, R1, V, VAL
      INTEGER           IT
C     .. Function Arguments ..
      DOUBLE PRECISION  F
      EXTERNAL          F
C     .. Scalars in Common ..
      DOUBLE PRECISION  AFLOW, ALP, AV, EPMACH, UFLOW
      INTEGER           IR, NT
C     .. Local Scalars ..
      DOUBLE PRECISION  ELIM, GM, PART, Q, RK, S, SLOPE, SLOPER, T, W, X
C     .. Intrinsic Functions ..
      INTRINSIC         ABS, EXP, DBLE
C     .. Common blocks ..
      COMMON            /CD01AH/ALP, AV, NT, IR
      COMMON            /DD01AH/EPMACH, UFLOW, AFLOW
C     .. Executable Statements ..
      SLOPER = 1.0D0
      T = V
      IF (IR.EQ.0) GO TO 20
C
C     RANDOM TRANSFORMATION
      PART = 1.0D0 - ALP*(A+B)
      T = ALP*A*B + (PART+ALP*V)*V
      SLOPER = PART + 2.0D0*ALP*V
   20 IF (IT.EQ.0) GO TO 100
      IF (B.EQ.R1) GO TO 80
C
C     LEFT ENDPOINT PEAK
      RK = B - A
      W = A
   40 S = T - W
      GM = 0.0D0
      ELIM = AFLOW/DBLE(NT)
      Q = S/RK
      IF (ABS(Q).GT.EXP(ELIM)) GM = Q**NT
      X = 0.0D0
      IF (S.EQ.0.0D0) GO TO 60
      IF (ABS(GM).GT.UFLOW/ABS(S)) X = S*GM
   60 SLOPE = DBLE(NT+1)*GM*SLOPER
      GO TO 120
C
C     RIGHT ENDPOINT PEAK
   80 RK = A - B
      W = B
      GO TO 40
  100 X = T
      W = 0.0D0
      SLOPE = SLOPER
  120 VAL = SLOPE*F(X+W)
      RETURN
      END

      SUBROUTINE D01AHX(A,B,RESULT,K,EPSIL,NPTS,ICHECK,F,AMAXL,AMAXR,R1,
     *                  IT)
C     MARK 8 RELEASE. NAG COPYRIGHT 1979.
C     MARK 8A REVISED. IER-255 (AUG 1980).
C     MARK 10A REVISED. IER-388 (OCT 1982).
C     MARK 10B REVISED. IER-413 (JAN 1983).
C     MARK 11.5(F77) REVISED. (SEPT 1985.)
C     MARK 12B REVISED. IER-526 (FEB 1987).
C     MARK 13B REVISED. IER-652 (AUG 1988).
C
C     THIS ROUTINE SHOULD NOT BE CALLED DIRECTLY BUT UNDER
C     THE CONTROL OF  D01AHF  WHICH INITIALIZES
C     TRANSFORMATION PARAMETERS USED IN  D01AHW.
C     THIS SUBROUTINE ATTEMPTS TO CALCULATE THE INTEGRAL F(X)
C     OVER THE INTERVAL (A,B) WITH RELATIVE ERROR NOT
C     EXCEEDING EPSIL.
C     THE RESULT OBTAINED USING A SEQUENCE OF 1, 3, 7, 15, 31,
C     63, 127 AND 255 POINTS INTERLACING QUADRATURE RULES
C     BASED ON THE OPTIMAL EXTENSION OF THE 3 POINT GAUSS
C     RULE. (SEE PATTERSON,T.N.L.,
C     MATH.COMP,22,847-857,1968). ADDITIONALLY, THE
C     EPSILON-ALGORITHM  TABLEAU IS DEVELOPED
C     (WYNN,MTAC,VOL 10,91,1956) ALONG WITH THE SEQUENCE OF
C     RULES AND CONVERGENCE IS DEEMED TO HAVE OCCURRED WHEN
C     ON SCANNING THE TABLEAU THE LAST TWO MEMBERS OF A
C     COLUMN  (THE FIRST COLUMN BEING TAKEN AS THE RESULTS
C     OF THE SEQUENCE OF RULES) OR LAST MEMBERS OF ADJACENT
C     COLUMNS AGREE TO THE SPECIFIED RELATIVE ACCURACY.
C     IF CONVERGENCE HAS NOT BEEN ACHIEVED FOR THE 31 POINT RULE
C     AND  CRATE.LE.30  THEN THE INTEGRATION IS ABORTED,
C     OTHERWISE THE HIGHER ORDER RULES ARE INVOKED. IF
C     R1,R2 AND R3  ARE THE RESULTS OF THREE SUCCESSIVE
C     RULES THEN  CRATE=ABS((R1-R2)/(R2-R3)). THIS IS ALSO
C     USED IN THE SUBDIVISION STRATEGY.
C     THE ARGUMENTS ARE -
C     A       -  LOWER LIMIT OF INTEGRATION
C     B       -  UPPER LIMIT OF INTEGRATION
C     EPSIL   -  RELATIVE ACCURACY REQUIRED
C     F       -  F(Z,W)  IS A USER NAMED AND WRITTEN FUNCTION
C                EVALUATING THE INTEGRAND AT Z+W
C     RESULT  -  THIS ARRAY SHOULD BE DECLARED WITH AT LEAST 8
C                ELEMENTS.  IT NORMALLY HOLDS THE RESULTS OF THE
C                SEQUENCE OF RULES EXCEPT WHEN CONVERGENCE IS
C                OBTAINED FROM THE E-ALGORITHM WHEN THE LAST TWO
C                MEMBERS WILL CONTAIN THE LAST COMPARISONS.
C     K       -  RESULT(K)  HOLDS THE INTEGRAL VALUE TO THE
C                SPECIFIED ACCURACY.
C     NPTS    -  NUMBER OF INTEGRAND EVALUATIONS.
C     ICHECK  -  INDICATES THE OUTCOME OF THE INTEGRATION -
C                ICHECK = 0  CONVERGENCE USING THE SEQUENCE OF
C                            RULES ONLY OR USING THE SEQUENCE OF
C                            RULES AND E1 WHEN AT LEAST 15 POINTS
C                            HAVE BEEN USED.
C                ICHECK = 4  CONVERGENCE FROM THE EPSILON ALGORITHM
C                            TABLEAU (NORMALLY ACCURATE BUT LESS
C                            RELIABLE THAN  ICHECK = 0)
C                ICHECK = 1  CONVERGENCE NOT ACHIEVED
C     IT,R1   -  WHEN  IT  IS NON-ZERO A SINGULARITY WEAKENING
C                TRANSFORMATION WILL BE APPLIED AT ENDPOINT
C                 R1  USING SUBROUTINE  D01AHW.
C     AMAXL,AMAXR
C             -  WHEN CONVERGENCE IS NOT ACHIEVED INFORMATION IS
C                GENERATED ON THE RELATIVE GRADIENTS OF THE
C                INTEGRAND AT A (SIZE AMAXL) AND B (SIZE
C                AMAXR) USING THE SUBROUTINE D01AHV
C
C     .. Scalar Arguments ..
      DOUBLE PRECISION  A, AMAXL, AMAXR, B, EPSIL, R1
      INTEGER           ICHECK, IT, K, NPTS
C     .. Array Arguments ..
      DOUBLE PRECISION  RESULT(8)
C     .. Function Arguments ..
      DOUBLE PRECISION  F
      EXTERNAL          F
C     .. Scalars in Common ..
      DOUBLE PRECISION  AFLOW, CRATE, EPMACH, FZERO, UFLOW
      INTEGER           MRULE
C     .. Arrays in Common ..
      DOUBLE PRECISION  FUNCTM(127), FUNCTP(127)
C     .. Local Scalars ..
      DOUBLE PRECISION  ACUM
      DOUBLE PRECISION  A2, A3, B2, B3, C2, C3, DIFF, FABS, P2, P3, Q2,
     *                  Q3, R2, R3, SUM, T0, T1, T2, T3, T4, TEMP, TEST,
     *                  X, Y
      INTEGER           I, IW, K1, KP, LP, NB, NTOP
C     .. Local Arrays ..
      DOUBLE PRECISION  P(127), W(254)
      LOGICAL           BAD(8)
C     .. External Functions ..
      DOUBLE PRECISION  D01AHU
      EXTERNAL          D01AHU
C     .. External Subroutines ..
      EXTERNAL          D01AHV, D01AHW
C     .. Intrinsic Functions ..
      INTRINSIC         ABS, MAX
C     .. Common blocks ..
      COMMON            /AD01AH/CRATE, MRULE
      COMMON            /BD01AH/FUNCTP, FUNCTM, FZERO
      COMMON            /DD01AH/EPMACH, UFLOW, AFLOW
C     .. Statement Functions ..
      LOGICAL           COMPAR
C     .. Data statements ..
      DATA              A3, B3, C3, P3, Q3, R3/6*0.0D0/
      DATA              P(1), P(2), P(3), P(4), P(5), P(6), P(7), P(8),
     *                  P(9), P(10), P(11), P(12), P(13), P(14), P(15),
     *                  P(16), P(17), P(18), P(19), P(20), P(21), P(22),
     *                  P(23), P(24), P(25), P(26), P(27), P(28)/
     *    .999997596379748464620D 0,.999982430354891598580D 0,
     *    .999943996207054375764D 0,.999872888120357611938D 0,
     *    .999760490924432047330D 0,.999598799671910683252D 0,
     *    .999380338025023581928D 0,.999098124967667597662D 0,
     *    .998745614468095114704D 0,.998316635318407392531D 0,
     *    .997805354495957274562D 0,.997206259372221959076D 0,
     *    .996514145914890273849D 0,.995724104698407188509D 0,
     *    .994831502800621000519D 0,.993831963212755022209D 0,
     *    .992721344282788615328D 0,.991495721178106132398D 0,
     *    .990151370400770159181D 0,.988684757547429479939D 0,
     *    .987092527954034067190D 0,.985371499598520371114D 0,
     *    .983518657578632728762D 0,.981531149553740106867D 0,
     *    .979406281670862683806D 0,.977141514639705714156D 0,
     *    .974734459752402667761D 0,.972182874748581796578D 0/
      DATA              P(29), P(30), P(31), P(32), P(33), P(34), P(35),
     *                  P(36), P(37), P(38), P(39), P(40), P(41), P(42),
     *                  P(43), P(44), P(45), P(46), P(47), P(48), P(49),
     *                  P(50), P(51), P(52), P(53), P(54), P(55), P(56)/
     *    .969484659502459231771D 0,.966637851558416567092D 0,
     *    .963640621569812132521D 0,.960491268708020283423D 0,
     *    .957188216109860962736D 0,.953730006425761136415D 0,
     *    .950115297521294876558D 0,.946342858373402905148D 0,
     *    .942411565191083059813D 0,.938320397779592883655D 0,
     *    .934068436157725787999D 0,.929654857429740056670D 0,
     *    .925078932907075652364D 0,.920340025470012420730D 0,
     *    .915437587155765040644D 0,.910371156957004292498D 0,
     *    .905140358813261595189D 0,.899744899776940036639D 0,
     *    .894184568335559022859D 0,.888459232872256998890D 0,
     *    .882568840247341906842D 0,.876513414484705269742D 0,
     *    .870293055548113905851D 0,.863907938193690477146D 0,
     *    .857358310886232156525D 0,.850644494768350279758D 0,
     *    .843766882672708601038D 0,.836725938168868735503D 0/
      DATA              P(57), P(58), P(59), P(60), P(61), P(62), P(63),
     *                  P(64), P(65), P(66), P(67), P(68), P(69), P(70),
     *                  P(71), P(72), P(73), P(74), P(75), P(76), P(77),
     *                  P(78), P(79), P(80), P(81), P(82), P(83), P(84)/
     *    .829522194637401400178D 0,.822156254364980407373D 0,
     *    .814628787655137413436D 0,.806940531950217611856D 0,
     *    .799092290960841401800D 0,.791084933799848361435D 0,
     *    .782919394118283016385D 0,.774596669241483377036D 0,
     *    .766117819303760090717D 0,.757483966380513637926D 0,
     *    .748696293616936602823D 0,.739756044352694758677D 0,
     *    .730664521242181261329D 0,.721423085370098915485D 0,
     *    .712033155362252034587D 0,.702496206491527078610D 0,
     *    .692813769779114702895D 0,.682987431091079228087D 0,
     *    .673018830230418479199D 0,.662909660024780595461D 0,
     *    .652661665410017496101D 0,.642276642509759513774D 0,
     *    .631756437711194230414D 0,.621102946737226402941D 0,
     *    .610318113715186400156D 0,.599403930242242892974D 0,
     *    .588362434447662541434D 0,.577195710052045814844D 0/
      DATA              P(85), P(86), P(87), P(88), P(89), P(90), P(91),
     *                  P(92), P(93), P(94), P(95), P(96), P(97), P(98),
     *                  P(99), P(100), P(101), P(102), P(103), P(104),
     *                  P(105), P(106), P(107), P(108), P(109), P(110),
     *                  P(111), P(112)/
     *    .565905885423654422623D 0,.554495132631932548866D 0,
     *    .542965666498311490492D 0,.531319743644375623972D 0,
     *    .519559661537457021993D 0,.507687757533716602155D 0,
     *    .495706407918761460170D 0,.483618026945841027562D 0,
     *    .471425065871658876934D 0,.459130011989832332873D 0,
     *    .446735387662028473742D 0,.434243749346802558002D 0,
     *    .421657686626163300056D 0,.408979821229888672409D 0,
     *    .396212806057615939183D 0,.383359324198730346916D 0,
     *    .370422087950078230138D 0,.357403837831532152376D 0,
     *    .344307341599438022777D 0,.331135393257976833093D 0,
     *    .317890812068476683182D 0,.304576441556714043335D 0,
     *    .291195148518246681964D 0,.277749822021824315065D 0,
     *    .264243372410926761945D 0,.250678730303483176613D 0,
     *    .237058845589829727213D 0,.223386686428966881628D 0/
      DATA              P(113), P(114), P(115), P(116), P(117), P(118),
     *                  P(119), P(120), P(121), P(122), P(123), P(124),
     *                  P(125), P(126), P(127)/
     *    .209665238243181194766D 0,.195897502711100153915D 0,
     *    .182086496759252198246D 0,.168235251552207464982D 0,
     *    .154346811481378108692D 0,.140424233152560174594D 0,
     *    .126470584372301966851D 0,.112488943133186625746D 0,
     *    .984823965981192020903D-1,.844540400837108837102D-1,
     *    .704069760428551790633D-1,.563443130465927899720D-1,
     *    .422691647653636032124D-1,.281846489497456943394D-1,
     *    .140938864107824626142D-1/
      DATA              W(1), W(2), W(3), W(4), W(5), W(6), W(7), W(8),
     *                  W(9), W(10), W(11), W(12), W(13), W(14), W(15),
     *                  W(16), W(17), W(18), W(19), W(20), W(21), W(22),
     *                  W(23), W(24), W(25), W(26), W(27), W(28)/
     *    .555555555555555555556D 0,.888888888888888888889D 0,
     *    .104656226026467265194D 0,.268488089868333440729D 0,
     *    .401397414775962222905D 0,.450916538658474142345D 0,
     *    .170017196299402603390D-1,.516032829970797396969D-1,
     *    .929271953151245376859D-1,.134415255243784220360D 0,
     *    .171511909136391380787D 0,.200628529376989021034D 0,
     *    .219156858401587496404D 0,.225510499798206687386D 0,
     *    .254478079156187441540D-2,.843456573932110624631D-2,
     *    .164460498543878109338D-1,.258075980961766535646D-1,
     *    .359571033071293220968D-1,.464628932617579865414D-1,
     *    .569795094941233574122D-1,.672077542959907035404D-1,
     *    .768796204990035310427D-1,.857559200499903511542D-1,
     *    .936271099812644736167D-1,.100314278611795578771D 0,
     *    .105669893580234809744D 0,.109578421055924638237D 0/
      DATA              W(29), W(30), W(31), W(32), W(33), W(34), W(35),
     *                  W(36), W(37), W(38), W(39), W(40), W(41), W(42),
     *                  W(43), W(44), W(45), W(46), W(47), W(48), W(49),
     *                  W(50), W(51), W(52), W(53), W(54), W(55), W(56)/
     *    .111956873020953456880D 0,.112755256720768691607D 0,
     *    .363221481845530659694D-3,.126515655623006801137D-2,
     *    .257904979468568827243D-2,.421763044155885483908D-2,
     *    .611550682211724633968D-2,.822300795723592966926D-2,
     *    .104982469096213218983D-1,.129038001003512656260D-1,
     *    .154067504665594978021D-1,.179785515681282703329D-1,
     *    .205942339159127111492D-1,.232314466399102694433D-1,
     *    .258696793272147469108D-1,.284897547458335486125D-1,
     *    .310735511116879648799D-1,.336038771482077305417D-1,
     *    .360644327807825726401D-1,.384398102494555320386D-1,
     *    .407155101169443189339D-1,.428779600250077344929D-1,
     *    .449145316536321974143D-1,.468135549906280124026D-1,
     *    .485643304066731987159D-1,.501571393058995374137D-1,
     *    .515832539520484587768D-1,.528349467901165198621D-1/
      DATA              W(57), W(58), W(59), W(60), W(61), W(62), W(63),
     *                  W(64), W(65), W(66), W(67), W(68), W(69), W(70),
     *                  W(71), W(72), W(73), W(74), W(75), W(76), W(77),
     *                  W(78), W(79), W(80), W(81), W(82), W(83), W(84)/
     *    .539054993352660639269D-1,.547892105279628650322D-1,
     *    .554814043565593639878D-1,.559784365104763194076D-1,
     *    .562776998312543012726D-1,.563776283603847173877D-1,
     *    .505360952078625176247D-4,.180739564445388357820D-3,
     *    .377746646326984660274D-3,.632607319362633544219D-3,
     *    .938369848542381500794D-3,.128952408261041739210D-2,
     *    .168114286542146990631D-2,.210881524572663287933D-2,
     *    .256876494379402037313D-2,.305775341017553113613D-2,
     *    .357289278351729964938D-2,.411150397865469304717D-2,
     *    .467105037211432174741D-2,.524912345480885912513D-2,
     *    .584344987583563950756D-2,.645190005017573692280D-2,
     *    .707248999543355546805D-2,.770337523327974184817D-2,
     *    .834283875396815770558D-2,.898927578406413572328D-2,
     *    .964117772970253669530D-2,.102971169579563555237D-1/
      DATA              W(85), W(86), W(87), W(88), W(89), W(90), W(91),
     *                  W(92), W(93), W(94), W(95), W(96), W(97), W(98),
     *                  W(99), W(100), W(101), W(102), W(103), W(104),
     *                  W(105), W(106), W(107), W(108), W(109), W(110),
     *                  W(111), W(112)/
     *    .109557333878379016480D-1,.116157233199551347270D-1,
     *    .122758305600827700870D-1,.129348396636073734547D-1,
     *    .135915710097655467896D-1,.142448773729167743063D-1,
     *    .148936416648151820348D-1,.155367755558439824399D-1,
     *    .161732187295777199419D-1,.168019385741038652709D-1,
     *    .174219301594641737472D-1,.180322163903912863201D-1,
     *    .186318482561387901863D-1,.192199051247277660193D-1,
     *    .197954950480974994880D-1,.203577550584721594669D-1,
     *    .209058514458120238522D-1,.214389800125038672465D-1,
     *    .219563663053178249393D-1,.224572658268160987071D-1,
     *    .229409642293877487608D-1,.234067774953140062013D-1,
     *    .238540521060385400804D-1,.242821652033365993580D-1,
     *    .246905247444876769091D-1,.250785696529497687068D-1,
     *    .254457699654647658126D-1,.257916269760242293884D-1/
      DATA              W(113), W(114), W(115), W(116), W(117), W(118),
     *                  W(119), W(120), W(121), W(122), W(123), W(124),
     *                  W(125), W(126), W(127), W(128), W(129), W(130),
     *                  W(131), W(132), W(133), W(134), W(135), W(136),
     *                  W(137), W(138), W(139), W(140)/
     *    .261156733767060976805D-1,.264174733950582599310D-1,
     *    .266966229274503599062D-1,.269527496676330319634D-1,
     *    .271855132296247918192D-1,.273946052639814325161D-1,
     *    .275797495664818730349D-1,.277407021782796819939D-1,
     *    .278772514766137016085D-1,.279892182552381597038D-1,
     *    .280764557938172466068D-1,.281388499156271506363D-1,
     *    .281763190330166021307D-1,.281888141801923586938D-1,
     *    .693793643241082671695D-5,.251578703842806614886D-4,
     *    .532752936697806131254D-4,.903727346587511492612D-4,
     *    .135754910949228719730D-3,.188873264506504913661D-3,
     *    .249212400482997294025D-3,.316303660822264476886D-3,
     *    .389745284473282293216D-3,.469184924247850409755D-3,
     *    .554295314930374714918D-3,.644762041305724779327D-3,
     *    .740282804244503330463D-3,.840571432710722463647D-3/
      DATA              W(141), W(142), W(143), W(144), W(145), W(146),
     *                  W(147), W(148), W(149), W(150), W(151), W(152),
     *                  W(153), W(154), W(155), W(156), W(157), W(158),
     *                  W(159), W(160), W(161), W(162), W(163), W(164),
     *                  W(165), W(166), W(167), W(168)/
     *    .945361516858525382463D-3,.105440762286331677225D-2,
     *    .116748411742995940769D-2,.128438247189701017681D-2,
     *    .140490799565514464272D-2,.152887670508776556838D-2,
     *    .165611272815445260522D-2,.178644639175864982468D-2,
     *    .191971297101387241252D-2,.205575198932734652359D-2,
     *    .219440692536383883880D-2,.233552518605716087370D-2,
     *    .247895822665756793068D-2,.262456172740442956257D-2,
     *    .277219576459345099400D-2,.292172493791781975378D-2,
     *    .307301843470257832341D-2,.322595002508786846140D-2,
     *    .338039799108692038235D-2,.353624499771677773402D-2,
     *    .369337791702565081826D-2,.385168761663987092408D-2,
     *    .401106872407502339889D-2,.417141937698407885279D-2,
     *    .433264096809298285454D-2,.449463789203206786164D-2,
     *    .465731729975685477728D-2,.482058886485126834765D-2/
      DATA              W(169), W(170), W(171), W(172), W(173), W(174),
     *                  W(175), W(176), W(177), W(178), W(179), W(180),
     *                  W(181), W(182), W(183), W(184), W(185), W(186),
     *                  W(187), W(188), W(189), W(190), W(191), W(192),
     *                  W(193), W(194), W(195), W(196)/
     *    .498436456476553860120D-2,.514855847897817776184D-2,
     *    .531308660518705656629D-2,.547786669391895082402D-2,
     *    .564281810138444415845D-2,.580786165997756736349D-2,
     *    .597291956550816580495D-2,.613791528004138504348D-2,
     *    .630277344908575871716D-2,.646741983180368672737D-2,
     *    .663178124290188789412D-2,.679578550488277339479D-2,
     *    .695936140939042293944D-2,.712243868645838715317D-2,
     *    .728494798055380706388D-2,.744682083240759101741D-2,
     *    .760798966571905658322D-2,.776838777792199121996D-2,
     *    .792794933429484911025D-2,.808660936478885997097D-2,
     *    .824430376303286803055D-2,.840096928705193263543D-2,
     *    .855654356130768961917D-2,.871096507973208687358D-2,
     *    .886417320948249426411D-2,.901610819519564316003D-2,
     *    .916671116356078840671D-2,.931592412806939509316D-2/
      DATA              W(197), W(198), W(199), W(200), W(201), W(202),
     *                  W(203), W(204), W(205), W(206), W(207), W(208),
     *                  W(209), W(210), W(211), W(212), W(213), W(214),
     *                  W(215), W(216), W(217), W(218), W(219), W(220),
     *                  W(221), W(222), W(223), W(224)/
     *    .946368999383006529427D-2,.960995256236388300966D-2,
     *    .975465653631741146108D-2,.989774752404874974401D-2,
     *    .100391720440568407982D-1,.101788775292360797335D-1,
     *    .103168123309476216819D-1,.104529257229060119261D-1,
     *    .105871679048851979309D-1,.107194900062519336232D-1,
     *    .108498440893373140990D-1,.109781831526589124696D-1,
     *    .111044611340069265370D-1,.112286329134080493536D-1,
     *    .113506543159805966017D-1,.114704821146938743804D-1,
     *    .115880740330439525684D-1,.117033887476570031007D-1,
     *    .118163858908302357632D-1,.119270260530192700402D-1,
     *    .120352707852795626304D-1,.121410826016682996790D-1,
     *    .122444249816119858986D-1,.123452623722438384545D-1,
     *    .124435601907140352631D-1,.125392848264748843534D-1,
     *    .126324036435420787645D-1,.127228849827323829063D-1/
      DATA              W(225), W(226), W(227), W(228), W(229), W(230),
     *                  W(231), W(232), W(233), W(234), W(235), W(236),
     *                  W(237), W(238), W(239), W(240), W(241), W(242),
     *                  W(243), W(244), W(245), W(246), W(247), W(248),
     *                  W(249), W(250), W(251), W(252)/
     *    .128106981638773619668D-1,.128958134880121146942D-1,
     *    .129782022395373992858D-1,.130578366883530488402D-1,
     *    .131346900919601528364D-1,.132087366975291299655D-1,
     *    .132799517439305306504D-1,.133483114637251799531D-1,
     *    .134137930851100985130D-1,.134763748338165159817D-1,
     *    .135360359349562136137D-1,.135927566148123959096D-1,
     *    .136465181025712914284D-1,.136973026319907162581D-1,
     *    .137450934430018966323D-1,.137898747832409365174D-1,
     *    .138316319095064286765D-1,.138703510891398409970D-1,
     *    .139060196013254612635D-1,.139386257383068508043D-1,
     *    .139681588065169385157D-1,.139946091276190798519D-1,
     *    .140179680394566088099D-1,.140382278969086233034D-1,
     *    .140553820726499642772D-1,.140694249578135753181D-1,
     *    .140803519625536613248D-1,.140881595165083010653D-1/
      DATA              W(253), W(254)/
     *    .140928450691604083550D-1,.140944070900961793469D-1/
C     .. Statement Function definitions ..
      COMPAR(Y) = ABS(Y) .LE. TEST .OR. (TEST.LT.ABS(Y) .AND. ABS(Y)
     *            .LE.10.0D0*ABS(FABS)*EPMACH)
C     .. Executable Statements ..
      ICHECK = 0
      MRULE = 8
C
C     CHECK FOR TRIVAL CASE
      IF (ABS(A-B).LE.MAX(ABS(A),ABS(B))*EPMACH*10.0D0) GO TO 240
      IW = 0
      K = 1
      T1 = 0.0D0
      NB = 128
      NTOP = 0
      LP = 0
C
C     SCALE FACTORS
      SUM = (B+A)*0.5D0
      DIFF = (B-A)*0.5D0
      CALL D01AHW(F,SUM,A,B,R1,FZERO,IT)
C
C     1-POINT GAUSS
      RESULT(1) = 2.0D0*FZERO*DIFF
   20 IF (K.EQ.MRULE) GO TO 200
      IF (K.EQ.5 .AND. CRATE.LE.30.0D0) GO TO 200
      K = K + 1
      NB = NB/2
      LP = LP + LP + 1
      NTOP = NTOP + NB
      ACUM = 0.0D0
      KP = 0
      FABS = 0.0D0
      DO 60 I = NB, NTOP, NB
         IW = IW + 1
         KP = 1 - KP
         IF (KP.EQ.0) GO TO 40
         X = P(I)*DIFF
         CALL D01AHW(F,SUM+X,A,B,R1,FUNCTP(I),IT)
         CALL D01AHW(F,SUM-X,A,B,R1,FUNCTM(I),IT)
   40    ACUM = ACUM + W(IW)*(FUNCTP(I)+FUNCTM(I))
         FABS = FABS + W(IW)*(ABS(FUNCTP(I))+ABS(FUNCTM(I)))
   60 CONTINUE
      IW = IW + 1
      RESULT(K) = (ACUM+W(IW)*FZERO)*DIFF
      FABS = (FABS+W(IW)*ABS(FZERO))*DIFF
C
C     CHECK FOR CONVERGENCE
      TEST = EPSIL*ABS(RESULT(K))
      T0 = T1
      T1 = RESULT(K) - RESULT(K-1)
      IF (K.LT.3) GO TO 80
      BAD(K) = ABS(T1) .GT. ABS(T0)
C
C     CONVERGENCE RATE
      CRATE = 0.0D0
      IF (ABS(T0).GT.21.0D0*ABS(T1)) CRATE = 22.0D0
      IF (ABS(T0).GT.30.0D0*ABS(T1)) CRATE = 31.0D0
      IF (COMPAR(T1)) GO TO 220
C     E-ALGORITHM
   80 P2 = P3
      P3 = 1.0D0/D01AHU(T1)
      IF (K.EQ.2) GO TO 20
      A2 = A3
      TEMP = 1.0D0/D01AHU(P3-P2)
      A3 = RESULT(K-1) + TEMP
      IF (K.EQ.3) GO TO 20
      TEMP = A3 - RESULT(K)
      K1 = MAX(K-2,3)
      DO 90 I = K1, K
         IF (BAD(I)) GO TO 100
   90 CONTINUE
      IF ( .NOT. COMPAR(TEMP)) GO TO 100
      RESULT(K-1) = RESULT(K)
      RESULT(K) = A3
      GO TO 220
  100 T2 = A3 - A2
      K1 = MAX(K-3,3)
      DO 110 I = K1, K
         IF (BAD(I)) GO TO 120
  110 CONTINUE
      IF ( .NOT. COMPAR(T2)) GO TO 120
      RESULT(K-1) = A2
      RESULT(K) = A3
      GO TO 220
  120 Q2 = Q3
      Q3 = 1.0D0/D01AHU(T2) + P2
      IF (K.EQ.4) GO TO 20
      TEMP = 1.0D0/D01AHU(Q3-Q2)
      B2 = B3
      B3 = A2 + TEMP
      TEMP = B3 - A3
      K1 = MAX(K-4,3)
      DO 130 I = K1, K
         IF (BAD(I)) GO TO 140
  130 CONTINUE
      IF ( .NOT. COMPAR(TEMP)) GO TO 140
      RESULT(K-1) = A3
      RESULT(K) = B3
      GO TO 260
  140 IF (K.EQ.5) GO TO 20
      T3 = B3 - B2
      K1 = MAX(K-5,3)
      DO 150 I = K1, K
         IF (BAD(I)) GO TO 160
  150 CONTINUE
      IF ( .NOT. COMPAR(T3)) GO TO 160
      RESULT(K-1) = B2
      RESULT(K) = B3
      GO TO 260
  160 R2 = R3
      R3 = 1.0D0/D01AHU(T3) + Q2
      IF (K.EQ.6) GO TO 20
      C2 = C3
      TEMP = 1.0D0/D01AHU(R3-R2)
      C3 = B2 + TEMP
      TEMP = C3 - B3
      K1 = MAX(K-6,3)
      DO 170 I = K1, K
         IF (BAD(I)) GO TO 180
  170 CONTINUE
      IF ( .NOT. COMPAR(TEMP)) GO TO 180
      RESULT(K-1) = B3
      RESULT(K) = C3
      GO TO 260
  180 IF (K.EQ.7) GO TO 20
      T4 = C3 - C2
      K1 = MAX(K-7,3)
      DO 190 I = K1, K
         IF (BAD(I)) GO TO 20
  190 CONTINUE
      IF ( .NOT. COMPAR(T4)) GO TO 20
      RESULT(K-1) = C2
      RESULT(K) = C3
      GO TO 260
C
C     CONVERGENCE NOT ACHIEVED
  200 ICHECK = 1
      IF (K.LT.5) GO TO 280
C
C     CALCULATE VARIATION ON LEFT AND RIGHT
C     HALVES OF (A,B).
      CALL D01AHV(A,B,AMAXL,AMAXR)
C
C     NORMAL TERMINATION - DIRECT CONVERGENCE OR CONVERGENCE OF
C     E-ALGORITHM BEFORE THIRD LEVEL
  220 NPTS = LP + LP + 1
      RETURN
C
C     TRIVAL CASE
  240 K = 2
      RESULT(1) = 0.0D0
      RESULT(2) = 0.0D0
      NPTS = 0
      RETURN
C
C     CONVERGENCE OF E-ALGORITHM ONLY AT THIRD LEVEL - CONFIRMATION
C     NEEDED
  260 ICHECK = 4
      GO TO 220
  280 AMAXL = 0.0D0
      AMAXR = 0.0D0
      GO TO 220
      END

      DOUBLE PRECISION FUNCTION D01AHU(A)
C     MARK 8 RELEASE. NAG COPYRIGHT 1979.
C     MARK 11.5(F77) REVISED. (SEPT 1985.)
C     MARK 14 REVISED. IER-820 (DEC 1989).
C     USED TO AVOID ZERO DIVISIONS.
C     .. Scalar Arguments ..
      DOUBLE PRECISION                 A
C     .. Scalars in Common ..
      DOUBLE PRECISION                 AFLOW, EPMACH, UFLOW
C     .. Intrinsic Functions ..
      INTRINSIC                        ABS, MAX, SIGN
C     .. Common blocks ..
      COMMON                           /DD01AH/EPMACH, UFLOW, AFLOW
C     .. Executable Statements ..
      D01AHU = 10.0D0*UFLOW
      IF (A.EQ.0.0D0) RETURN
      D01AHU = SIGN(MAX(ABS(A),10.0D0*UFLOW),A)
      RETURN
      END

      SUBROUTINE D01BAZ(A,B,ITYPE,NPTS,WEIGHT,ABSCIS,IFAIL)
C     MARK 7 RELEASE. NAG COPYRIGHT 1978.
C     MARK 11.5(F77) REVISED. (SEPT 1985.)
C
C     RETURNS WEIGHTS AND PIVOTS FOR ONE GAUSS-LEGENDRE FORMULA IF
C     STORED
C     IFAIL = 1 - THE NPTS RULE IS NOT AMONG THOSE STORED
C     ( WEIGHT,ABSCIS EVALUATED FOR LARGEST VALID NPTS LESS THAN
C     REQUESTED VALUE)
C
C     THE WEIGHTS AND ABSCISSAE RETURNED DEPEND ON A AND B.
C     THOSE STORED ARE WEIGHTS AND ABSCISSAE FOR A=-1,B=+1
C     THOSE RETURNED FOR GENERAL (A,B) ARE RELATED TO THOSE STORED
C     BY
C     W(A,B) = 0.5 * (B-A) * W(-1,+1)
C     X(A,B) = 0.5 * (B-A) * X(-1,+1) + 0.5 * (A+B)
C
C     .. Scalar Arguments ..
      DOUBLE PRECISION  A, B
      INTEGER           IFAIL, ITYPE, NPTS
C     .. Array Arguments ..
      DOUBLE PRECISION  ABSCIS(NPTS), WEIGHT(NPTS)
C     .. Local Scalars ..
      DOUBLE PRECISION  HFRNGE, PNTMID
      INTEGER           I, IIJJ, N, NL, NN, NPTSA
C     .. Local Arrays ..
      DOUBLE PRECISION  ABST(136), WTST(136)
      INTEGER           NSTOR(16)
C     .. Data statements ..
      DATA              WTST(1), WTST(2), WTST(3), WTST(4),
     *                  WTST(5)/0.200000000000000000000000000000D1,
     *                  0.100000000000000000000000000000D1,
     *                  0.555555555555555555555555555555D0,
     *                  0.888888888888888888888888888888D0,
     *                  0.347854845137453857373063949221D0/
      DATA              WTST(6), WTST(7), WTST(08), WTST(09),
     *                  WTST(10)/0.652145154862546142626936050778D0,
     *                  0.236926885056189087514264040719D0,
     *                  0.478628670499366468041291514835D0,
     *                  0.568888888888888888888888888888D0,
     *                  0.171324492379170345040296142172D0/
      DATA              WTST(11), WTST(12), WTST(13), WTST(14),
     *                  WTST(15)/0.360761573048138607569833513837D0,
     *                  0.467913934572691047389870343989D0,
     *                  0.101228536290376259152531354309D0,
     *                  0.222381034453374470544355994426D0,
     *                  0.313706645877887287337962201986D0/
      DATA              WTST(16), WTST(17), WTST(18), WTST(19),
     *                  WTST(20)/0.362683783378361982965150449277D0,
     *                  0.666713443086881375935688098933D-1,
     *                  0.149451349150580593145776339657D0,
     *                  0.219086362515982043995534934228D0,
     *                  0.269266719309996355091226921569D0/
      DATA              WTST(21), WTST(22), WTST(23), WTST(24),
     *                  WTST(25)/0.295524224714752870173892994651D0,
     *                  0.471753363865118271946159614850D-1,
     *                  0.106939325995318430960254718193D0,
     *                  0.160078328543346226334652529543D0,
     *                  0.203167426723065921749064455809D0/
      DATA              WTST(26), WTST(27), WTST(28), WTST(29),
     *                  WTST(30)/0.233492536538354808760849898924D0,
     *                  0.249147045813402785000562436042D0,
     *                  0.351194603317518630318328761381D-1,
     *                  0.801580871597602098056332770628D-1,
     *                  0.121518570687903184689414809072D0/
      DATA              WTST(31), WTST(32), WTST(33), WTST(34),
     *                  WTST(35)/0.157203167158193534569601938623D0,
     *                  0.185538397477937813741716590125D0,
     *                  0.205198463721295603965924065661D0,
     *                  0.215263853463157790195876443316D0,
     *                  0.271524594117540948517805724560D-1/
      DATA              WTST(36), WTST(37), WTST(38), WTST(39),
     *                  WTST(40)/0.622535239386478928628438369943D-1,
     *                  0.951585116824927848099251076022D-1,
     *                  0.124628971255533872052476282192D0,
     *                  0.149595988816576732081501730547D0,
     *                  0.169156519395002538189312079030D0/
      DATA              WTST(41), WTST(42), WTST(43), WTST(44),
     *                  WTST(45)/0.182603415044923588866763667969D0,
     *                  0.189450610455068496285396723208D0,
     *                  0.176140071391521183118619623518D-1,
     *                  0.406014298003869413310399522749D-1,
     *                  0.626720483341090635695065351870D-1/
      DATA              WTST(46), WTST(47), WTST(48), WTST(49),
     *                  WTST(50)/0.832767415767047487247581432220D-1,
     *                  0.101930119817240435036750135480D0,
     *                  0.118194531961518417312377377711D0,
     *                  0.131688638449176626898494499748D0,
     *                  0.142096109318382051329298325067D0/
      DATA              WTST(51), WTST(52), WTST(53), WTST(54),
     *                  WTST(55)/0.149172986472603746787828737001D0,
     *                  0.152753387130725850698084331955D0,
     *                  0.123412297999871995468056670700D-1,
     *                  0.285313886289336631813078159518D-1,
     *                  0.442774388174198061686027482113D-1/
      DATA              WTST(56), WTST(57), WTST(58), WTST(59),
     *                  WTST(60)/0.592985849154367807463677585001D-1,
     *                  0.733464814110803057340336152531D-1,
     *                  0.861901615319532759171852029837D-1,
     *                  0.976186521041138882698806644642D-1,
     *                  0.107444270115965634782577342446D0/
      DATA              WTST(61), WTST(62), WTST(63), WTST(64),
     *                  WTST(65)/0.115505668053725601353344483906D0,
     *                  0.121670472927803391204463153476D0,
     *                  0.125837456346828296121375382511D0,
     *                  0.127938195346752156974056165224D0,
     *                  0.701861000947009660040706373885D-2/
      DATA              WTST(66), WTST(67), WTST(68), WTST(69),
     *                  WTST(70)/0.162743947309056706051705622063D-1,
     *                  0.253920653092620594557525897892D-1,
     *                  0.342738629130214331026877322523D-1,
     *                  0.428358980222266806568786466061D-1,
     *                  0.509980592623761761961632446895D-1/
      DATA              WTST(71), WTST(72), WTST(73), WTST(74),
     *                  WTST(75)/0.586840934785355471452836373001D-1,
     *                  0.658222227763618468376500637069D-1,
     *                  0.723457941088485062253993564784D-1,
     *                  0.781938957870703064717409188283D-1,
     *                  0.833119242269467552221990746043D-1/
      DATA              WTST(76), WTST(77), WTST(78), WTST(79),
     *                  WTST(80)/0.876520930044038111427714627518D-1,
     *                  0.911738786957638847128685771116D-1,
     *                  0.938443990808045656391802376681D-1,
     *                  0.956387200792748594190820022041D-1,
     *                  0.965400885147278005667648300635D-1/
      DATA              WTST(81), WTST(82), WTST(83), WTST(84),
     *                  WTST(85)/0.315334605230583863267731154389D-2,
     *                  0.732755390127626210238397962178D-2,
     *                  0.114772345792345394895926676090D-1,
     *                  0.155793157229438487281769558344D-1,
     *                  0.196161604573555278144607196522D-1/
      DATA              WTST(86), WTST(87), WTST(88), WTST(89),
     *                  WTST(90)/0.235707608393243791405193013784D-1,
     *                  0.274265097083569482000738362625D-1,
     *                  0.311672278327980889020657568463D-1,
     *                  0.347772225647704388925485859638D-1,
     *                  0.382413510658307063172172565237D-1/
      DATA              WTST(91), WTST(92), WTST(93), WTST(94),
     *                  WTST(95)/0.415450829434647492140588223610D-1,
     *                  0.446745608566942804194485871258D-1,
     *                  0.476166584924904748259066234789D-1,
     *                  0.503590355538544749578076190878D-1,
     *                  0.528901894851936670955050562646D-1/
      DATA              WTST(96), WTST(97), WTST(98), WTST(99),
     *                  WTST(100)/0.551995036999841628682034951916D-1,
     *                  0.572772921004032157051502346847D-1,
     *                  0.591148396983956357464748174335D-1,
     *                  0.607044391658938800529692320278D-1,
     *                  0.620394231598926639041977841375D-1/
      DATA              WTST(101), WTST(102), WTST(103), WTST(104),
     *                  WTST(105)/0.631141922862540256571260227502D-1,
     *                  0.639242385846481866239062018255D-1,
     *                  0.644661644359500822065041936577D-1,
     *                  0.647376968126839225030249387365D-1,
     *                  0.178328072169643294729607914497D-2/
      DATA              WTST(106), WTST(107), WTST(108), WTST(109),
     *                  WTST(110)/0.414703326056246763528753572855D-2,
     *                  0.650445796897836285611736039998D-2,
     *                  0.884675982636394772303091465973D-2,
     *                  0.111681394601311288185904930192D-1,
     *                  0.134630478967186425980607666859D-1/
      DATA              WTST(111), WTST(112), WTST(113), WTST(114),
     *                  WTST(115)/0.157260304760247193219659952975D-1,
     *                  0.179517157756973430850453020011D-1,
     *                  0.201348231535302093723403167285D-1,
     *                  0.222701738083832541592983303841D-1,
     *                  0.243527025687108733381775504090D-1/
      DATA              WTST(116), WTST(117), WTST(118), WTST(119),
     *                  WTST(120)/0.263774697150546586716917926252D-1,
     *                  0.283396726142594832275113052002D-1,
     *                  0.302346570724024788679740598195D-1,
     *                  0.320579283548515535854675043478D-1,
     *                  0.338051618371416093915654821107D-1/
      DATA              WTST(121), WTST(122), WTST(123), WTST(124),
     *                  WTST(125)/0.354722132568823838106931467152D-1,
     *                  0.370551285402400460404151018095D-1,
     *                  0.385501531786156291289624969468D-1,
     *                  0.399537411327203413866569261283D-1,
     *                  0.412625632426235286101562974736D-1/
      DATA              WTST(126), WTST(127), WTST(128), WTST(129),
     *                  WTST(130)/0.424735151236535890073397679088D-1,
     *                  0.435837245293234533768278609737D-1,
     *                  0.445905581637565630601347100309D-1,
     *                  0.454916279274181444797709969712D-1,
     *                  0.462847965813144172959532492322D-1/
      DATA              WTST(131), WTST(132), WTST(133), WTST(134),
     *                  WTST(135)/0.469681828162100173253262857545D-1,
     *                  0.475401657148303086622822069442D-1,
     *                  0.479993885964583077281261798713D-1,
     *                  0.483447622348029571697695271580D-1,
     *                  0.485754674415034269347990667839D-1/
      DATA              WTST(136)/0.486909570091397203833653907347D-1/
      DATA              ABST(1), ABST(2), ABST(3), ABST(4),
     *                  ABST(5)/0.000000000000000000000000000000D0,
     *                  0.577350269189625764509148780501D0,
     *                  0.774596669241483377035853079956D0,
     *                  0.000000000000000000000000000000D0,
     *                  0.861136311594052575223946488892D0/
      DATA              ABST(6), ABST(7), ABST(8), ABST(9),
     *                  ABST(10)/0.339981043584856264802665759103D0,
     *                  0.906179845938663992797626878299D0,
     *                  0.538469310105683091036314420700D0,
     *                  0.000000000000000000000000000000D0,
     *                  0.932469514203152027812301554493D0/
      DATA              ABST(11), ABST(12), ABST(13), ABST(14),
     *                  ABST(15)/0.661209386466264513661399595019D0,
     *                  0.238619186083196908630501721680D0,
     *                  0.960289856497536231683560868569D0,
     *                  0.796666477413626739591553936475D0,
     *                  0.525532409916328985817739049189D0/
      DATA              ABST(16), ABST(17), ABST(18), ABST(19),
     *                  ABST(20)/0.183434642495649804939476142360D0,
     *                  0.973906528517171720077964012084D0,
     *                  0.865063366688984510732096688423D0,
     *                  0.679409568299024406234327365114D0,
     *                  0.433395394129247190799265943165D0/
      DATA              ABST(21), ABST(22), ABST(23), ABST(24),
     *                  ABST(25)/0.148874338981631210884826001129D0,
     *                  0.981560634246719250690549090149D0,
     *                  0.904117256370474856678465866119D0,
     *                  0.769902674194304687036893833212D0,
     *                  0.587317954286617447296702418940D0/
      DATA              ABST(26), ABST(27), ABST(28), ABST(29),
     *                  ABST(30)/0.367831498998180193752691536643D0,
     *                  0.125233408511468915472441369463D0,
     *                  0.986283808696812338841597266704D0,
     *                  0.928434883663573517336391139377D0,
     *                  0.827201315069764993189794742650D0/
      DATA              ABST(31), ABST(32), ABST(33), ABST(34),
     *                  ABST(35)/0.687292904811685470148019803019D0,
     *                  0.515248636358154091965290718551D0,
     *                  0.319112368927889760435671824168D0,
     *                  0.108054948707343662066244650219D0,
     *                  0.989400934991649932596154173450D0/
      DATA              ABST(36), ABST(37), ABST(38), ABST(39),
     *                  ABST(40)/0.944575023073232576077988415534D0,
     *                  0.865631202387831743880467897712D0,
     *                  0.755404408355003033895101194847D0,
     *                  0.617876244402643748446671764048D0,
     *                  0.458016777657227386342419442983D0/
      DATA              ABST(41), ABST(42), ABST(43), ABST(44),
     *                  ABST(45)/0.281603550779258913230460501460D0,
     *                  0.950125098376374401853193354249D-1,
     *                  0.993128599185094924786122388471D0,
     *                  0.963971927277913791267666131197D0,
     *                  0.912234428251325905867752441203D0/
      DATA              ABST(46), ABST(47), ABST(48), ABST(49),
     *                  ABST(50)/0.839116971822218823394529061701D0,
     *                  0.746331906460150792614305070355D0,
     *                  0.636053680726515025452836696226D0,
     *                  0.510867001950827098004364050955D0,
     *                  0.373706088715419560672548177024D0/
      DATA              ABST(51), ABST(52), ABST(53), ABST(54),
     *                  ABST(55)/0.227785851141645078080496195368D0,
     *                  0.765265211334973337546404093988D-1,
     *                  0.995187219997021360179997409700D0,
     *                  0.974728555971309498198391993008D0,
     *                  0.938274552002732758523649001708D0/
      DATA              ABST(56), ABST(57), ABST(58), ABST(59),
     *                  ABST(60)/0.886415527004401034213154341982D0,
     *                  0.820001985973902921953949872669D0,
     *                  0.740124191578554364243828103099D0,
     *                  0.648093651936975569252495786910D0,
     *                  0.545421471388839535658375617218D0/
      DATA              ABST(61), ABST(62), ABST(63), ABST(64),
     *                  ABST(65)/0.433793507626045138487084231913D0,
     *                  0.315042679696163374386793291319D0,
     *                  0.191118867473616309158639820757D0,
     *                  0.640568928626056260850430826247D-1,
     *                  0.997263861849481563544981128665D0/
      DATA              ABST(66), ABST(67), ABST(68), ABST(69),
     *                  ABST(70)/0.985611511545268335400175044630D0,
     *                  0.964762255587506430773811928118D0,
     *                  0.934906075937739689170919134835D0,
     *                  0.896321155766052123965307243719D0,
     *                  0.849367613732569970133693004967D0/
      DATA              ABST(71), ABST(72), ABST(73), ABST(74),
     *                  ABST(75)/0.794483795967942406963097298970D0,
     *                  0.732182118740289680387426665091D0,
     *                  0.663044266930215200975115168663D0,
     *                  0.587715757240762329040745476401D0,
     *                  0.506899908932229390023747474377D0/
      DATA              ABST(76), ABST(77), ABST(78), ABST(79),
     *                  ABST(80)/0.421351276130635345364119436172D0,
     *                  0.331868602282127649779916805730D0,
     *                  0.239287362252137074544603209165D0,
     *                  0.144471961582796493485186373598D0,
     *                  0.483076656877383162348125704405D-1/
      DATA              ABST(81), ABST(82), ABST(83), ABST(84),
     *                  ABST(85)/0.998771007252426118600541491563D0,
     *                  0.993530172266350757547928750849D0,
     *                  0.984124583722826857744583600026D0,
     *                  0.970591592546247250461411983800D0,
     *                  0.952987703160430860722960666025D0/
      DATA              ABST(86), ABST(87), ABST(88), ABST(89),
     *                  ABST(90)/0.931386690706554333114174380101D0,
     *                  0.905879136715569672822074835671D0,
     *                  0.876572020274247885905693554805D0,
     *                  0.843588261624393530711089844519D0,
     *                  0.807066204029442627082553043024D0/
      DATA              ABST(91), ABST(92), ABST(93), ABST(94),
     *                  ABST(95)/0.767159032515740339253855437522D0,
     *                  0.724034130923814654674482233493D0,
     *                  0.677872379632663905211851280675D0,
     *                  0.628867396776513623995164933069D0,
     *                  0.577224726083972703817809238540D0/
      DATA              ABST(96), ABST(97), ABST(98), ABST(99),
     *                  ABST(100)/0.523160974722233033678225869137D0,
     *                  0.466902904750958404544928861650D0,
     *                  0.408686481990716729916225495814D0,
     *                  0.348755886292160738159817937270D0,
     *                  0.287362487355455576735886461316D0/
      DATA              ABST(101), ABST(102), ABST(103), ABST(104),
     *                  ABST(105)/0.224763790394689061224865440174D0,
     *                  0.161222356068891718056437390783D0,
     *                  0.970046992094626989300539558536D-1,
     *                  0.323801709628693620333222431521D-1,
     *                  0.999305041735772139456905624345D0/
      DATA              ABST(106), ABST(107), ABST(108), ABST(109),
     *                  ABST(110)/0.996340116771955279346924500676D0,
     *                  0.991013371476744320739382383443D0,
     *                  0.983336253884625956931299302156D0,
     *                  0.973326827789910963741853507352D0,
     *                  0.961008799652053718918614121897D0/
      DATA              ABST(111), ABST(112), ABST(113), ABST(114),
     *                  ABST(115)/0.946411374858402816062481491347D0,
     *                  0.929569172131939575821490154559D0,
     *                  0.910522137078502805756380668008D0,
     *                  0.889315445995114105853404038272D0,
     *                  0.865999398154092819760783385070D0/
      DATA              ABST(116), ABST(117), ABST(118), ABST(119),
     *                  ABST(120)/0.840629296252580362751691544695D0,
     *                  0.813265315122797559741923338086D0,
     *                  0.783972358943341407610220525213D0,
     *                  0.752819907260531896611863774885D0,
     *                  0.719881850171610826848940217831D0/
      DATA              ABST(121), ABST(122), ABST(123), ABST(124),
     *                  ABST(125)/0.685236313054233242563558371031D0,
     *                  0.648965471254657339857761231993D0,
     *                  0.611155355172393250248852971018D0,
     *                  0.571895646202634034283878116659D0,
     *                  0.531279464019894545658013903544D0/
      DATA              ABST(126), ABST(127), ABST(128), ABST(129),
     *                  ABST(130)/0.489403145707052957478526307021D0,
     *                  0.446366017253464087984947714758D0,
     *                  0.402270157963991603695766771260D0,
     *                  0.357220158337668115950442615046D0,
     *                  0.311322871990210956157512698560D0/
      DATA              ABST(131), ABST(132), ABST(133), ABST(134),
     *                  ABST(135)/0.264687162208767416373964172510D0,
     *                  0.217423643740007084149648748988D0,
     *                  0.169644420423992818037313629748D0,
     *                  0.121462819296120554470376463492D0,
     *                  0.729931217877990394495429419403D-1/
      DATA              ABST(136)/0.243502926634244325089558428537D-1/
      DATA              NSTOR(1), NSTOR(2), NSTOR(3), NSTOR(4)/1, 2, 3,
     *                  4/
      DATA              NSTOR(5), NSTOR(6), NSTOR(7), NSTOR(8)/5, 6, 8,
     *                  10/
      DATA              NSTOR(9), NSTOR(10), NSTOR(11), NSTOR(12)/12,
     *                  14, 16, 20/
      DATA              NSTOR(13), NSTOR(14), NSTOR(15), NSTOR(16)/24,
     *                  32, 48, 64/
C     .. Executable Statements ..
      DO 20 I = 1, NPTS
         WEIGHT(I) = 0.0D0
         ABSCIS(I) = 0.0D0
   20 CONTINUE
      N = 0
      NPTSA = 0
      IFAIL = 0
      DO 40 I = 1, 16
         IF (NPTS.LT.NSTOR(I)) GO TO 60
         N = N + (NPTSA+1)/2
         NPTSA = NSTOR(I)
         IF (NPTS.EQ.NSTOR(I)) GO TO 80
   40 CONTINUE
   60 IFAIL = 1
   80 HFRNGE = 0.5D0*(B-A)
      PNTMID = 0.5D0*(A+B)
      NL = NPTSA/2
      IF (NL.LT.1) GO TO 120
      DO 100 NN = 1, NL
         N = N + 1
         IIJJ = NPTSA + 1 - NN
         ABSCIS(NN) = HFRNGE*ABST(N) + PNTMID
         WEIGHT(NN) = HFRNGE*WTST(N)
         ABSCIS(IIJJ) = -HFRNGE*ABST(N) + PNTMID
         WEIGHT(IIJJ) = HFRNGE*WTST(N)
  100 CONTINUE
  120 IF (NPTSA.LE.(NL+NL)) GO TO 140
      N = N + 1
      ABSCIS(NL+1) = HFRNGE*ABST(N) + PNTMID
      WEIGHT(NL+1) = HFRNGE*WTST(N)
  140 RETURN
      END

      DOUBLE PRECISION FUNCTION D01BAF(WTFUN,A,B,NPTS,FUN,IFAIL)
C     MARK 7 RELEASE. NAG COPYRIGHT 1978.
C     MARK 8A REVISED. IER-250 (JULY 1980).
C     MARK 11.5(F77) REVISED. (SEPT 1985.)
C
C     EVALUATES INTEGRAL OF FUNCTION FUN BY NPTS GAUSS FORMULA OF
C     TYPE WTFUN
C     IFAIL = 1 - THE NPTS RULE IS NOT AMONG THOSE STORED
C     ( ANSWER EVALUATED FOR LARGEST VALID NPTS LESS THAN REQUESTED
C     VALUE)
C     IFAIL = 2 - VALUES OF A OR B INVALID
C     ( ANSWER RETURNED AS ZERO)
C
C     WTFUN
C     .. Parameters ..
      CHARACTER*6                      SRNAME
      PARAMETER                        (SRNAME='D01BAF')
C     .. Scalar Arguments ..
      DOUBLE PRECISION                 A, B
      INTEGER                          IFAIL, NPTS
C     .. Function Arguments ..
      DOUBLE PRECISION                 FUN
      EXTERNAL                         FUN
C     .. Subroutine Arguments ..
      EXTERNAL                         WTFUN
C     .. Local Scalars ..
      DOUBLE PRECISION                 AA, SUM, WW
      INTEGER                          I, IERR, NPTSA
C     .. Local Arrays ..
      DOUBLE PRECISION                 ABSCIS(64), WEIGHT(64)
      CHARACTER*1                      P01REC(1)
C     .. External Functions ..
      INTEGER                          P01ABF
      EXTERNAL                         P01ABF
C     .. External Subroutines ..
      EXTERNAL                         D01BBF
C     .. Intrinsic Functions ..
      INTRINSIC                        MIN
C     .. Executable Statements ..
      SUM = 0.0D0
      NPTSA = MIN(NPTS,64)
      IERR = 1
      CALL D01BBF(WTFUN,A,B,1,NPTSA,WEIGHT,ABSCIS,IERR)
      IF (IERR.GT.1) GO TO 40
      IF (NPTS.NE.NPTSA) IERR = 1
      DO 20 I = 1, NPTSA
         WW = WEIGHT(I)
         IF (WW.EQ.0.0D0) GO TO 20
         AA = ABSCIS(I)
         SUM = SUM + WW*FUN(AA)
   20 CONTINUE
      IF (IERR.EQ.0) GO TO 60
   40 IFAIL = P01ABF(IFAIL,IERR,SRNAME,0,P01REC)
      GO TO 80
   60 IFAIL = 0
   80 D01BAF = SUM
      RETURN
      END

      DOUBLE PRECISION FUNCTION D01AHF(A,B,EPR,NPTS,RELERR,F,NL,IFAIL)
C     MARK 8 RELEASE. NAG COPYRIGHT 1979.
C     MARK 8A REVISED. IER-254 (AUG 1980).
C     MARK 11.5(F77) REVISED. (SEPT 1985.)
C     MARK 12B REVISED. IER-525 (FEB 1987).
C     MARK 13 REVISED. USE OF MARK 12 X02 FUNCTIONS (APR 1988).
C     MARK 14 REVISED. IER-819 (DEC 1989).
C
C     THIS FUNCTION ROUTINE PERFORMS AUTOMATIC INTEGRATION OVER A
C     FINITE INTERVAL USING THE BASIC INTEGRATION ALGORITHMS D01AHY
C     AND D01AHX, TOGETHER WITH, IF NECESSARY, AN ADAPTIVE
C     SUBDIVISION PROCESS.
C
C     INPUT ARGUMENTS
C     ----- ----------
C     A,B     -  LOWER AND UPPER INTEGRATION LIMITS.
C     EPR     -  REQUIRED RELATIVE ACCURACY.
C     NL      -  APPROXIMATE LIMIT ON NUMBER OF INTEGRAND
C                EVALUATIONS. IF SET NEGATIVE OR ZERO THE
C                DEFAULT IS 10000.
C     F       -  THE USER NAMED AND PREPARED FUNCTION  F(X)
C                GIVES THE VALUE OF THE INTEGRAND AT X.
C     IFAIL      INTEGER VARIABLE
C             - 0  FOR HARD FAIL REPORT
C             - 1  FOR SOFT FAIL REPORT
C
C     OUTPUT ARGUMENTS
C     ------ ----------
C     NPTS    -  NUMBER OF INTEGRAND EVALUATIONS USED IN OBTAINING
C                THE RESULT.
C     RELERR  -  ROUGH ESTIMATE OF RELATIVE ACCURACY ACHIEVED.
C     IFAIL   -  VALUE INDICATES THE OUTCOME OF THE INTEGRATION -
C                IFAIL  = 0  CONVERGED
C                IFAIL  = 1  INTEGRAND EVALUATIONS EXCEEDED  NL.
C                            THE RESULT WAS OBTAINED BY CONTINUING
C                            BUT IGNORING ANY NEED TO SUBDIVIDE.
C                            RESULT LIKELY TO BE INACCURATE.
C                IFAIL  = 2  DURING THE SUBDIVISION PROCESS
C                            THE STACK BECAME FULL
C                            (PRESENTLY SET TO HOLD 20
C                            LEVELS OF INFORMATION.  MAY BE
C                            INCREASED BY  ALTERING  ISMAX
C                            AND THE DIMENSIONS OF STACK
C                            AND ISTACK). RESULT IS
C                            OBTAINED BY CONTINUING BUT
C                            IGNORING CONVERGENCE FAILURES
C                            ON INTERVALS  WHICH CANNOT BE
C                            ACCOMMODATED ON THE STACKS.
C                            RESULT LIKELY TO BE
C                            INACCURATE.
C                IFAIL  = 3  INVALID ACCURACY REQUEST.
C
C     THE SUBDIVISION STRATEGY IS AS FOLLOWS -
C     AT EACH STAGE AN INTERVAL IS PRESENTED FOR SUBDIVISION
C     (INITIALLY THE WHOLE INTERVAL). THE POINT OF SUBDIVISION IS
C     DETERMINED BY THE RELATIVE GRADIENT OF THE INTEGRAND
C     AT THE END POINTS (SEE D01AHZ) AND MAY BE IN THE
C     RATIO 1/2, 1/1 OR 2/1.D01AHY IS THEN APPLIED TO EACH
C     SUBINTERVAL.  SHOULD IT FAIL TO CONVERGE ON THE LEFT
C     SUBINTERVAL THE SUBINTERVAL IS STACKED FOR FUTURE
C     EXAMINATION AND THE RIGHT SUBINTERVAL IMMEDIATELY
C     EXAMINED. SHOULD  IT FAIL ON THE RIGHT SUBINTERVAL
C     SUBDIVISION IS IMMEDIATELY PERFORMED AND THE WHOLE
C     PROCESS REPEATED. EACH CONVERGED RESULT IS
C     ACCUMULATED AS THE PARTIAL VALUE OF THE INTEGRAL.
C     WHEN THE LEFT  AND RIGHT SUBINTERVALS BOTH CONVERGE
C     THE INTERVAL LAST STACKED IS SUBDIVIDED AND THE
C     PROCESS REPEATED.
C     A NUMBER OF REFINEMENTS ARE INCLUDED.  ATTEMPTS ARE MADE TO
C     DETECT LARGE VARIATIONS IN THE INTEGRAND AND
C     TRANSFORMATIONS ARE MADE IF ENDPOINT VARIATION IS
C     EXTREME. THIS DEPENDS ON THE RATE OF CONVERGENCE OF
C     D01AHX AND ON THE END POINT RELATIVE GRADIENTS OF THE
C     INTEGRAND FOR THE NON-SUBDIVIDED INTERVAL.  RANDOM
C     TRANSFORMATIONS ARE ALSO APPLIED TO IMPROVE THE
C     RELIABILITY.  THE  RELATIVE ACCURACY REQUESTED ON
C     EACH SUBINTERVAL IS ADJUSTED IN ACCORDANCE WITH ITS
C     LIKELY CONTRIBUTION TO THE TOTAL INTEGRAL.
C
C     .. Parameters ..
      CHARACTER*6                      SRNAME
      PARAMETER                        (SRNAME='D01AHF')
C     .. Scalar Arguments ..
      DOUBLE PRECISION                 A, B, EPR, RELERR
      INTEGER                          IFAIL, NL, NPTS
C     .. Function Arguments ..
      DOUBLE PRECISION                 F
      EXTERNAL                         F
C     .. Scalars in Common ..
      DOUBLE PRECISION                 AFLOW, ALP, AV, CRATE, EPMACH,
     *                                 UFLOW
      INTEGER                          IR, MRULE, NT
C     .. Local Scalars ..
      DOUBLE PRECISION                 QSUBND
      DOUBLE PRECISION                 AMAXL, AMAXR, C2, COMP, EPS,
     *                                 EPSIL, EPSR, FACTOR, SUB1, SUB2,
     *                                 SUB3, TEST, V
      INTEGER                          IC, ICQ, IL, IS, ISI, ISMAX, IT,
     *                                 K, KK, NF, NLIM, NLIMIT, NTMAX
C     .. Local Arrays ..
      DOUBLE PRECISION                 RESULT(8), STACK(120)
      INTEGER                          ISTACK(20)
      CHARACTER*1                      P01REC(1)
C     .. External Functions ..
      DOUBLE PRECISION                 D01AHU, D01AHZ, X02AJF, X02AMF
      INTEGER                          P01ABF
      EXTERNAL                         D01AHU, D01AHZ, X02AJF, X02AMF,
     *                                 P01ABF
C     .. External Subroutines ..
      EXTERNAL                         D01AHY
C     .. Intrinsic Functions ..
      INTRINSIC                        ABS, LOG, MAX, MIN, SIGN
C     .. Common blocks ..
      COMMON                           /AD01AH/CRATE, MRULE
      COMMON                           /CD01AH/ALP, AV, NT, IR
      COMMON                           /DD01AH/EPMACH, UFLOW, AFLOW
C     .. Data statements ..
      DATA                             ISMAX, NLIM, NTMAX, TEST/116,
     *                                 10000, 10, 0.25D0/
C     .. Executable Statements ..
      IL = 3
      ICQ = IFAIL
      IF (EPR.LE.0.0D0) GO TO 220
C     EPMACH SHOULD BE SLIGHTLY LARGER THAN THE RELATIVE
C     MACHINE ACCURACY.
      EPMACH = 1.1D0*X02AJF()
C     UFLOW IS THE SMALLEST POSITIVE REAL NUMBER REPRESENTABLE
C     ON THE MACHINE WHICH CAN BE INVERTED WITHOUT OVERFLOW.
      UFLOW = X02AMF()
      AFLOW = LOG(X02AMF())
      CRATE = 0.0D0
      EPSR = EPR/10.0D0
      NLIMIT = NL
      IF (NLIMIT.LE.0) NLIMIT = NLIM
      EPSIL = MIN(EPSR,1.0D-3)
      CALL D01AHY(A,B,RESULT,K,EPSIL,NPTS,IFAIL,F,AMAXL,AMAXR,A,0)
      D01AHF = RESULT(K)
      RELERR = ABS(RESULT(K)-RESULT(K-1))
      IF (ABS(D01AHF).GT.100.0D0*UFLOW) RELERR = RELERR/D01AHF
      RELERR = MAX(RELERR,0.5D0*EPMACH)
C
C     CHECK IF SUBDIVISION IS NEEDED
      IF (IFAIL.EQ.0) RETURN
C
C     SUBDIVIDE
      EPSIL = EPSIL*0.5D0
      FACTOR = 1.0D0
      NT = 1
      RELERR = 0.0D0
      QSUBND = 0.0D0
      D01AHF = 0.0D0
      IS = 1
      ISI = 1
      IC = 1
      SUB1 = A
      SUB3 = B
   20 IF (ABS(SUB1-SUB3).LT.20.0D0*EPSIL*(ABS(SUB1)+ABS(SUB3))) THEN
         K = 1
         RESULT(K) = F((SUB1+SUB3)/2.0D0)*(SUB3-SUB1)
         COMP = 0.0D0
         NPTS = NPTS + 1
         GO TO 160
      END IF
      SUB2 = D01AHZ(SUB1,SUB3,AMAXL,AMAXR)
      EPS = MIN(0.5D-3,FACTOR*EPSIL)
C
C     PROCESS SUBINTERVAL (SUB1,SUB2)
      IT = 0
      IF (AMAXL.GT.TEST .AND. CRATE.LE.21.0D0) IT = 1
      V = AMAXR
      C2 = CRATE
      CALL D01AHY(SUB1,SUB2,RESULT,K,EPS,NF,IFAIL,F,AMAXL,AMAXR,SUB1,IT)
      NPTS = NPTS + NF
      IF (NPTS.LE.NLIMIT) GO TO 40
      IC = SIGN(2,IC)
   40 COMP = ABS(RESULT(K)-RESULT(K-1))
      IF (IFAIL.EQ.0) GO TO 100
      IF (ABS(IC).EQ.2) GO TO 100
      IF (IS.GE.ISMAX) GO TO 80
C
C     STACK SUBINTERVAL (SUB1,SUB2) FOR FUTURE EXAMINATION
      IF (RESULT(K).EQ.0.0D0) RESULT(K) = D01AHF
      STACK(IS) = MAX(1.0D0,ABS(D01AHF/RESULT(K))*0.1D0)
      IS = IS + 1
      STACK(IS) = SUB1
      IS = IS + 1
      STACK(IS) = SUB2
      IS = IS + 1
      STACK(IS) = AMAXL
      IS = IS + 1
      STACK(IS) = AMAXR
      IS = IS + 1
      STACK(IS) = CRATE
      IS = IS + 1
      KK = NT
      IF (IT.EQ.0) GO TO 60
      IF (IFAIL.EQ.4) GO TO 60
      IF (NT.GE.NTMAX) GO TO 60
      KK = NT + 1
   60 ISTACK(ISI) = KK
      ISI = ISI + 1
      GO TO 120
   80 IC = -ABS(IC)
  100 QSUBND = QSUBND + RESULT(K)
      D01AHF = QSUBND
      RELERR = RELERR + COMP
C
C     PROCESS SUBINTERVAL (SUB2,SUB3)
  120 IT = 0
      IF (V.GT.TEST .AND. C2.LE.21.0D0) IT = 1
      CALL D01AHY(SUB2,SUB3,RESULT,K,EPS,NF,IFAIL,F,AMAXL,AMAXR,SUB3,IT)
      NPTS = NPTS + NF
      IF (NPTS.LE.NLIMIT) GO TO 140
      IC = SIGN(2,IC)
  140 COMP = ABS(RESULT(K)-RESULT(K-1))
      IF (IFAIL.EQ.0) GO TO 160
      IF (ABS(IC).EQ.2) GO TO 160
C
C     SUBDIVIDE INTERVAL (SUB2,SUB3)
      IF (IT.EQ.1 .AND. IFAIL.NE.4) NT = NT + 1
      SUB1 = SUB2
      IF (RESULT(K).EQ.0.0D0) RESULT(K) = D01AHF
      FACTOR = MAX(1.0D0,ABS(D01AHF/RESULT(K))*0.1D0)
      GO TO 20
  160 QSUBND = QSUBND + RESULT(K)
      D01AHF = QSUBND
      RELERR = RELERR + COMP
      IF (IS.EQ.1) GO TO 180
C
C     SUBDIVIDE THE DELINQUENT INTERVAL LAST STACKED
      ISI = ISI - 1
      NT = ISTACK(ISI)
      IS = IS - 1
      CRATE = STACK(IS)
      IS = IS - 1
      AMAXR = STACK(IS)
      IS = IS - 1
      AMAXL = STACK(IS)
      IS = IS - 1
      SUB3 = STACK(IS)
      IS = IS - 1
      SUB1 = STACK(IS)
      IS = IS - 1
      FACTOR = STACK(IS)
      GO TO 20
C
C     SUBDIVISION RESULT
  180 IF (ABS(D01AHF).GT.100.0D0*UFLOW)
     *    RELERR = ABS(RELERR/D01AHU(D01AHF))
      RELERR = MAX(RELERR,0.5D0*EPMACH)
      IF (IC.NE.1) GO TO 200
      IFAIL = 0
      RETURN
  200 IL = 2
      IF (IC.LT.0) GO TO 220
      IL = 1
  220 IFAIL = P01ABF(ICQ,IL,SRNAME,0,P01REC)
      RETURN
      END

      SUBROUTINE D01BBF(WTFUN,A,B,ITYPE,NPTS,WEIGHT,ABSCIS,IFAIL)
C     MARK 7 RELEASE. NAG COPYRIGHT 1978.
C     MARK 11.5(F77) REVISED. (SEPT 1985.)
C
C     RETURNS WEIGHTS AND PIVOTS FOR ONE GAUSS-WTFUN FORMULA IF
C     STORED
C     IFAIL = 1 - THE NPTS RULE IS NOT AMONG THOSE STORED
C     ( WEIGHT,ABSCIS EVALUATED FOR LARGEST VALID NPTS LESS THAN
C     REQUESTED VALUE)
C     IFAIL = 2 - VALUES OF A OR B INVALID
C     ( ALL WEIGHTS AND ABSCISSAE RETURNED AS ZERO)
C     IFAIL = 3 - UNDERFLOW IN EVALUATING LAGUERRE OR HERMITE
C     NORMAL WEIGHTS
C     ( THE UNDERFLOWING WEIGHTS ARE RETURNED AS ZERO)
C
C     THE WEIGHTS AND ABSCISSAE RETURNED DEPEND ON A AND B.
C
C     WTFUN
C     .. Parameters ..
      CHARACTER*6       SRNAME
      PARAMETER         (SRNAME='D01BBF')
C     .. Scalar Arguments ..
      DOUBLE PRECISION  A, B
      INTEGER           IFAIL, ITYPE, NPTS
C     .. Array Arguments ..
      DOUBLE PRECISION  ABSCIS(NPTS), WEIGHT(NPTS)
C     .. Subroutine Arguments ..
      EXTERNAL          WTFUN
C     .. Local Scalars ..
      INTEGER           IERR
C     .. Local Arrays ..
      CHARACTER*1       P01REC(1)
C     .. External Functions ..
      INTEGER           P01ABF
      EXTERNAL          P01ABF
C     .. Executable Statements ..
      CALL WTFUN(A,B,ITYPE,NPTS,WEIGHT,ABSCIS,IERR)
      IF (IERR.EQ.0) GO TO 20
      IFAIL = P01ABF(IFAIL,IERR,SRNAME,0,P01REC)
      RETURN
   20 IFAIL = 0
      RETURN
      END
      DOUBLE PRECISION FUNCTION G05CAF(X)
C     MARK 14 RE-ISSUE. NAG COPYRIGHT 1989.
C
C     Returns a pseudo-random number uniformly distributed between
C     A and B.
C
C     Pseudo-random numbers are generated by the auxiliary routine
C     G05CAY, 63 at a time, and stored in the array RV in common block
C     CG05CA. G05CAF copies one number from the array RV into X,
C     calling G05CAY to replenish RV when necessary.
C
C     This revised version of G05CAF has been introduced for
C     compatibility with the new routines G05FAF, G05FBF and G05FDF,
C     introduced at Mark 14.
C
C     Jeremy Du Croz, NAG Ltd, June 1989.
C
C     .. Parameters ..
      INTEGER                          LV
      PARAMETER                        (LV=63)
C     .. Scalar Arguments ..
      DOUBLE PRECISION                 X
C     .. Scalars in Common ..
      INTEGER                          KV
C     .. Arrays in Common ..
      DOUBLE PRECISION                 RV(LV)
C     .. Local Scalars ..
      LOGICAL                          INIT
C     .. External Subroutines ..
      EXTERNAL                         G05CAY, G05CAZ
C     .. Common blocks ..
      COMMON                           /CG05CA/RV, KV
C     .. Save statement ..
      SAVE                             INIT, /CG05CA/
C     .. Data statements ..
      DATA                             INIT/.TRUE./
C     .. Executable Statements ..
C
C     Ensure that KV in common block /CG05CA/ has been initialized
C
      IF (INIT) CALL G05CAZ(INIT)
C
C     Replenish the buffer if necessary
C
      IF (KV.GE.LV) CALL G05CAY(.FALSE.)
C
      KV = KV + 1
      G05CAF = RV(KV)
      RETURN
      END
      INTEGER FUNCTION P01ABF(IFAIL,IERROR,SRNAME,NREC,REC)
C     MARK 11.5(F77) RELEASE. NAG COPYRIGHT 1986.
C     MARK 13 REVISED. IER-621 (APR 1988).
C     MARK 13B REVISED. IER-668 (AUG 1988).
C
C     P01ABF is the error-handling routine for the NAG Library.
C
C     P01ABF either returns the value of IERROR through the routine
C     name (soft failure), or terminates execution of the program
C     (hard failure). Diagnostic messages may be output.
C
C     If IERROR = 0 (successful exit from the calling routine),
C     the value 0 is returned through the routine name, and no
C     message is output
C
C     If IERROR is non-zero (abnormal exit from the calling routine),
C     the action taken depends on the value of IFAIL.
C
C     IFAIL =  1: soft failure, silent exit (i.e. no messages are
C                 output)
C     IFAIL = -1: soft failure, noisy exit (i.e. messages are output)
C     IFAIL =-13: soft failure, noisy exit but standard messages from
C                 P01ABF are suppressed
C     IFAIL =  0: hard failure, noisy exit
C
C     For compatibility with certain routines included before Mark 12
C     P01ABF also allows an alternative specification of IFAIL in which
C     it is regarded as a decimal integer with least significant digits
C     cba. Then
C
C     a = 0: hard failure  a = 1: soft failure
C     b = 0: silent exit   b = 1: noisy exit
C
C     except that hard failure now always implies a noisy exit.
C
C     S.Hammarling, M.P.Hooper and J.J.du Croz, NAG Central Office.
C
C     .. Scalar Arguments ..
      INTEGER                 IERROR, IFAIL, NREC
      CHARACTER*(*)           SRNAME
C     .. Array Arguments ..
      CHARACTER*(*)           REC(*)
C     .. Local Scalars ..
      INTEGER                 I, NERR
      CHARACTER*72            MESS
C     .. External Subroutines ..
      EXTERNAL                P01ABZ, X04AAF, X04BAF
C     .. Intrinsic Functions ..
      INTRINSIC               ABS, MOD
C     .. Executable Statements ..
      IF (IERROR.NE.0) THEN
C        Abnormal exit from calling routine
         IF (IFAIL.EQ.-1 .OR. IFAIL.EQ.0 .OR. IFAIL.EQ.-13 .OR.
     *       (IFAIL.GT.0 .AND. MOD(IFAIL/10,10).NE.0)) THEN
C           Noisy exit
            CALL X04AAF(0,NERR)
            DO 20 I = 1, NREC
               CALL X04BAF(NERR,REC(I))
   20       CONTINUE
            IF (IFAIL.NE.-13) THEN
               WRITE (MESS,FMT=99999) SRNAME, IERROR
               CALL X04BAF(NERR,MESS)
               IF (ABS(MOD(IFAIL,10)).NE.1) THEN
C                 Hard failure
                  CALL X04BAF(NERR,
     *                     ' ** NAG hard failure - execution terminated'
     *                        )
                  CALL P01ABZ
               ELSE
C                 Soft failure
                  CALL X04BAF(NERR,
     *                        ' ** NAG soft failure - control returned')
               END IF
            END IF
         END IF
      END IF
      P01ABF = IERROR
      RETURN
C
99999 FORMAT (' ** ABNORMAL EXIT from NAG Library routine ',A,': IFAIL',
     *  ' =',I6)
      END

      SUBROUTINE P01ABZ
C     MARK 11.5(F77) RELEASE. NAG COPYRIGHT 1986.
C
C     Terminates execution when a hard failure occurs.
C
C     ******************** IMPLEMENTATION NOTE ********************
C     The following STOP statement may be replaced by a call to an
C     implementation-dependent routine to display a message and/or
C     to abort the program.
C     *************************************************************
C     .. Executable Statements ..
      STOP
      END

      DOUBLE PRECISION FUNCTION X02AJF()
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C
C     RETURNS  (1/2)*B**(1-P)  IF ROUNDS IS .TRUE.
C     RETURNS  B**(1-P)  OTHERWISE
C
      DOUBLE PRECISION X02CON
      DATA X02CON /1.11022302462516D-16 /
C     .. Executable Statements ..
      X02AJF = X02CON
      RETURN
      END
      SUBROUTINE X04AAF(I,NERR)
C     MARK 7 RELEASE. NAG COPYRIGHT 1978
C     MARK 7C REVISED IER-190 (MAY 1979)
C     MARK 11.5(F77) REVISED. (SEPT 1985.)
C     MARK 14 REVISED. IER-829 (DEC 1989).
C     IF I = 0, SETS NERR TO CURRENT ERROR MESSAGE UNIT NUMBER
C     (STORED IN NERR1).
C     IF I = 1, CHANGES CURRENT ERROR MESSAGE UNIT NUMBER TO
C     VALUE SPECIFIED BY NERR.
C
C     .. Scalar Arguments ..
      INTEGER           I, NERR
C     .. Local Scalars ..
      INTEGER           NERR1
C     .. Save statement ..
      SAVE              NERR1
C     .. Data statements ..
      DATA              NERR1/0/
C     .. Executable Statements ..
      IF (I.EQ.0) NERR = NERR1
      IF (I.EQ.1) NERR1 = NERR
      RETURN
      END
      SUBROUTINE X04BAF(NOUT,REC)
C     MARK 11.5(F77) RELEASE. NAG COPYRIGHT 1986.
C
C     X04BAF writes the contents of REC to the unit defined by NOUT.
C
C     Trailing blanks are not output, except that if REC is entirely
C     blank, a single blank character is output.
C     If NOUT.lt.0, i.e. if NOUT is not a valid Fortran unit identifier,
C     then no output occurs.
C
C     .. Scalar Arguments ..
      INTEGER           NOUT
      CHARACTER*(*)     REC
C     .. Local Scalars ..
      INTEGER           I
C     .. Intrinsic Functions ..
      INTRINSIC         LEN
C     .. Executable Statements ..
      IF (NOUT.GE.0) THEN
C        Remove trailing blanks
         DO 20 I = LEN(REC), 2, -1
            IF (REC(I:I).NE.' ') GO TO 40
   20    CONTINUE
C        Write record to external file
   40    WRITE (NOUT,FMT=99999) REC(1:I)
      END IF
      RETURN
C
99999 FORMAT (A)
      END
      SUBROUTINE G05CAZ(INIT)
C     MARK 14 RE-ISSUE. NAG COPYRIGHT 1989.
C
C     called by G05CAF, G05CBF, G05CCF, G05CFZ, G05CGZ, G05DGF, G05FAF,
C     G05FBF AND G05FDF to ensure that the contents of common blocks
C     /AG05CA/, /BG05CA/, /CG05CA/ and /DG05CA/ are initialized.
C
C     ******************** ADVICE FOR IMPLEMENTORS *********************
C
C     This version of G05CAZ must be used in conjunction with the
C     new auxiliary routine G05CAY which has been introduced at Mark 14.
C
C     These notes are intended to guide implementors through the text
C     changes necessary to implement the basic random number generator
C     routines G05CAY, G05CAZ, G05CBF, G05CCF, G05CFZ, G05CGZ. Please
C     follow these guidelines, and consult NAG Central Office if in any
C     doubt or difficulty. Please send a listing of your final text for
C     these routines to Central Office.
C
C     1.  Prepare code for G05CAY following guidelines supplied there.
C
C     2.  Read "DETAILS-NOTE-1" below.
C
C     3.  Activate all lines beginning CAnn, where nn is the value of
C         ILIM used in G05CAY.
C
C     ******************************************************************
C
C     ************************ DETAILS-NOTE-1 **************************
C
C     G05CAZ must be implemented consistently with G05CAY.
C
C     If G05CAY has been implemented simply by selecting suitable
C     variant code according to the value of ILIM, then a consistent
C     implementation of G05CAY may be obtained by using the variant
C     code supplied in comments beginning CAnn where the digits nn
C     are the value of ILIM.
C
C     If G05CAY has been implemented in machine code, it will still
C     be possible on many machines to implement G05CAZ in Fortran
C     and this will be satisfactory since it is not important for
C     G05CAZ to be particularly efficient. Essentially the code for
C     G05CAZ depends only on how the internal variable N is stored in
C     the array B in the common block /AG05CA/ and the code given
C     below should be applicable provided that N is stored in
C     accordance with a particular value of ILIM as defined in the
C     text of G05CAY.
C
C     ******************************************************************
C
C     .. Parameters ..
      INTEGER           LV
      PARAMETER         (LV=63)
      INTEGER           ILIM
      PARAMETER         (ILIM=4)
CA03  PARAMETER         (ILIM=3)
CA02  PARAMETER         (ILIM=2)
C     .. Scalar Arguments ..
      LOGICAL           INIT
C     .. Scalars in Common ..
      DOUBLE PRECISION  GAMMA, NORMAL, VNORML
      INTEGER           DEFOPT, OPTION, POSSOP
C     .. Arrays in Common ..
      INTEGER           B(0:LV,ILIM)
C     .. Local Scalars ..
      LOGICAL           INIT2
C     .. External Subroutines ..
      EXTERNAL          G05CAY
C     .. Common blocks ..
      COMMON            /AG05CA/B, OPTION, POSSOP, DEFOPT
      COMMON            /BG05CA/NORMAL, GAMMA
      COMMON            /DG05CA/VNORML
C     .. Save statement ..
      SAVE              INIT2, /AG05CA/, /BG05CA/, /DG05CA/
C     .. Data statements ..
      DATA              INIT2/.TRUE./
C     .. Executable Statements ..
C
C     If INIT2 is not already .FALSE. , initialize /AG05CA/, /BG05CA/
C     and /DG05CA/ and set INIT2 to .FALSE.
C
      IF (INIT2) THEN
C
         B(0,1) =  6698
         B(0,2) =  7535
         B(0,3) = 26792
         B(0,4) = 30140
CA03     B(0,1) = 498218
CA03     B(0,2) = 172267
CA03     B(0,3) = 964506
CA02     B(0,1) = 246913578
CA02     B(0,2) = 987654312
         OPTION = 0
         DEFOPT = 0
         POSSOP = 0
C
         NORMAL = 1.0D0
         GAMMA = -1.0D0
         VNORML = 256.0D0
C
         INIT2 = .FALSE.
C
C        Initialize the buffer
C
         CALL G05CAY(.TRUE.)
      END IF
C
C     Set INIT to .FALSE. in any case
C
      INIT = .FALSE.
C
      RETURN
      END
      SUBROUTINE G05CAY(REINIT)
C     MARK 14 RELEASE. NAG COPYRIGHT 1989.
C
C     called by G05CAF, G05FAF, G05FBF or G05FDF when needed, to fill
C     the internal array RV in COMMON block CG05CA with new
C     pseudo-random numbers.
C
C     G05CAY uses a multiplicative congruential algorithm
C
C     N := N * 13**13 modulo 2**59
C
C     where N is a notional variable internal to G05CAY. The value of N
C     is converted to a real number in the range 0.0 to 1.0 by scaling
C     by 2**(-59), with care taken that the result lies strictly
C     between 0.0 and 1.0.
C
C     N is initially set to 123456789*(2**32+1) but can be changed
C     by a call to G05CBF or G05CCF.
C
C     G05CAY generates number 63 at a time, in order to achieve
C     efficiency on vector-processing machines. The first call of
C     G05CAY generates 63 consecutive values of N, N(i), i = 1,...,63.
C     Subsequent calls generate the next set of 63 values of N by
C
C     N(i) := N(i) * (13**13)**63 modulo 2**59, for i = 1,...,63.
C
C     The value 63 is defined as the symbol LV in a parameter statement
C     in each routine which needs it. The particular value 63 was
C     chosen because of special properties of the multiplier
C     (13**13)**63 modulo 2**59, which permit efficient multi-length
C     arithmetic when ILIM = 4 (see below). Only a few values of LV
C     have such properties.
C
C     ******************** ADVICE FOR IMPLEMENTORS *********************
C
C     These notes are intended to guide implementors through the text
C     changes necessary to implement the basic random number generator
C     routines G05CAY, G05CAZ, G05CBF, G05CCF, G05CFZ, G05CGZ. Please
C     follow these guidelines, and consult NAG Central Office if in any
C     doubt or difficulty. Please send a listing of your final text for
C     these routines to Central Office.
C
C     1.  Read "DETAILS-NOTE-1" below.
C         Decide the relevant value of ILIM, say nn, taking account of
C         the suggestion for 'long' integers.
C
C     2.  Activate all lines beginning CAnn.
C
C     3.  Read "DETAILS-NOTE-2" below.
C         Check whether your compiler has the functions ISHFT and IAND
C         (or equivalent functions) and compiles inline code for them.
C
C     4.  If ISHFT and IAND or equivalent functions are available as
C         inline functions, activate all lines beginning CYnn. If
C         necessary, change the function names. Otherwise activate all
C         lines beginning CXnn.
C
C     ******************************************************************
C
C     ************************ DETAILS-NOTE-1 **************************
C
C     The algorithm requires that the values of N and of the multi-
C     plier 13**13 be stored as 59-bit unsigned integers and that
C     the least significant 59 bits of their product be computed. On
C     most machines this can be done much more efficiently in
C     machine code than in Fortran. The Fortran code given here is
C     intended to give guidance on a machine code implementation,
C     and to provide a less efficient implementation as a fall-back.
C
C     The 59-bit integer N is stored as a multiple-length integer in
C     the array B. In fact for convenience the 60-bit integer 2*N is
C     stored. The multiplier 13**13 is stored in the array M.
C     The multiplier (13**13)**63 modulo 2**59 is stored in the array
C     MLV in exactly the same way as the basic multiplier is stored in
C     the array M.
C
C     The number of elements in N and M (ILIM) and the number of bits
C     used in each element of N and M (IBITS) depend on the number
C     of bits (including sign) in an integer variable as follows -
C
C        ILIM     IBITS     number of bits in integer variable
C          4        15                 .ge. 32
C          3        20                 .ge. 41
C          2        30                 .ge. 60
C
C     For greatest efficiency ILIM should be chosen as small as
C     possible.
C
C     N.B. the most significant bits of N are stored in B(I,ILIM),
C     the next most significant bits in B(I,ILIM-1), . . . , and
C     the least significant bits in B(I,1). The multiplier is stored
C     in M(ILIM), M(ILIM-1), . . . , M(1) in the same way.
C
C     Note -
C
C     1) in the above table the value of IBITS is less than half the
C     number of bits in an integer variable. This ensures that the
C     necessary integer products can be formed and summed correctly
C     without integer overflow. However many machines have instruc-
C     tions for forming double-length integer products. A machine
C     code implementation can take advantage of this and allow IBITS
C     to be as large (or almost as large) as the number of bits in
C     an integer variable and ILIM to be correspondingly smaller.
C     This should be much more efficient.
C
C     2) the figures in the rightmost column in the above table are
C     correct for the specific value of the multiplier. They are
C     certainly not correct for arbitrary 60-bit arithmetic.
C
C     3) it may well be advantageous to use 'long' integers, if
C     available, within G05CAY, even if they are not used
C     elsewhere in the library.
C
C     Variant code for the array declarations and data statements
C     is supplied in comments beginning CAnn where the digits nn are
C     the value of ILIM.
C
C     ******************************************************************
C
C     .. Parameters ..
      INTEGER           LV
      PARAMETER         (LV=63)
      INTEGER           ILIM
      PARAMETER         (ILIM=4)
CA03  PARAMETER         (ILIM=3)
CA02  PARAMETER         (ILIM=2)
      DOUBLE PRECISION  ONE, R2
      PARAMETER         (ONE=1.0D0,R2=0.5D0)
      DOUBLE PRECISION  RP1, RP2
      PARAMETER         (RP1=R2**60,RP2=R2**30)
CA03  DOUBLE PRECISION  RP1, RP2
CA03  PARAMETER         (RP1=R2**60,RP2=R2**40)
CA02  DOUBLE PRECISION  RP1
CA02  PARAMETER         (RP1=R2**60)
C     .. Scalar Arguments ..
      LOGICAL           REINIT
C     .. Scalars in Common ..
      INTEGER           DEFOPT, OPTION, POSSOP, KV
C     .. Arrays in Common ..
      DOUBLE PRECISION  RV(LV)
      INTEGER           B(0:LV,ILIM)
C     .. Local Scalars ..
      DOUBLE PRECISION  ONEM
      INTEGER           I, T1, T2, T3, U, V
CX03  INTEGER           I, T1, T2, U, V
CX02  INTEGER           I, T1, U, V
CY04  INTEGER           I, T1, T2, T3, T4
CY03  INTEGER           I, T1, T2, T3
CY02  INTEGER           I, T1, T2
      LOGICAL           INIT
C     .. Local Arrays ..
      INTEGER           M(ILIM), MLV(ILIM)
C     .. External Functions ..
      DOUBLE PRECISION  X02AJF
      EXTERNAL          X02AJF
C     .. Intrinsic Functions ..
      INTRINSIC         SIGN
C     .. Common blocks ..
      COMMON            /AG05CA/B, OPTION, POSSOP, DEFOPT
      COMMON            /CG05CA/RV, KV
C     .. Save statement ..
      SAVE              /AG05CA/, /CG05CA/, ONEM, INIT
C     .. Data statements ..
      DATA              INIT / .TRUE. /
      DATA              M /
     *                  17917, 13895, 19930,     8 /
CA03 *                  247293, 485810,    275 /
CA02 *                  455329277,    282074 /
      DATA              MLV /
     *                  85,  3703,  6070,  6822 /
CA03 *                  753749, 972915, 218309 /
CA02 *                  121339989, 223549366 /
C     .. Executable Statements ..
C
C     ************************ DETAILS-NOTE-2 **************************
C
C     It is advantageous to use non-standard Fortran intrinsic
C     functions for shifting and masking if these are available and if
C     they are compiled as in-line code without the overhead of a
C     subroutine call. Alternative code is given which uses the integer
C     functions:
C
C     ISHFT(I,J) to shift I J bits to the left (a negative value of
C                 J indicating a right shift)
C     IAND(I,J)  to form the logical and of I and J
C
C     It may be necesssary to replace these by calls to different
C     intrinsic functions provided by the fortran compiler.
C
C     Variant code for this computation is supplied in comments
C     beginning CXnn (using only arithmetic operations) or in
C     comments beginning CYnn (using shifting and masking functions)
C     where the digits nn are the value of ILIM.
C
C     ******************************************************************
C
      IF (INIT.OR.REINIT) THEN
         INIT = .FALSE.
         ONEM = ONE - X02AJF()
C
C        Generate first buffer of LV integers by multiplying
C        recursively by M modulo 2**59.
C        This loop cannot be vectorized.
C
         DO 20 I = 1, LV
            V = B(I-1,1)*M(1)
            U = V/32768
            B(I,1) = V - 32768*U
            V = U + B(I-1,2)*M(1) + B(I-1,1)*M(2)
            U = V/32768
            B(I,2) = V - 32768*U
            V = U + B(I-1,3)*M(1) + B(I-1,2)*M(2) + B(I-1,1)*M(3)
            U = V/32768
            B(I,3) = V - 32768*U
            V = U + B(I-1,4)*M(1) + B(I-1,3)*M(2) + B(I-1,2)*M(3)
     *            + B(I-1,1)*M(4)
            U = V/32768
            B(I,4) = V - 32768*U
CX03        V = B(I-1,1)*M(1)
CX03        U = V/1048576
CX03        B(I,1) = V - 1048576*U
CX03        V = U + B(I-1,2)*M(1) + B(I-1,1)*M(2)
CX03        U = V/1048576
CX03        B(I,2) = V - 1048576*U
CX03        V = U + B(I-1,3)*M(1) + B(I-1,2)*M(2) + B(I-1,1)*M(3)
CX03        U = V/1048576
CX03        B(I,3) = V - 1048576*U
CX02        V = B(I-1,1)*M(1)
CX02        U = V/1073741824
CX02        B(I,1) = V - 1073741824*U
CX02        V = U + B(I-1,2)*M(1) + B(I-1,1)*M(2)
CX02        U = V/1073741824
CX02        B(I,2) = V - 1073741824*U
CY04        T1 = B(I-1,1)*M(1)
CY04        T2 = ISHFT(T1,-15) + B(I-1,2)*M(1) + B(I-1,1)*M(2)
CY04        T3 = ISHFT(T2,-15) + B(I-1,3)*M(1) + B(I-1,2)*M(2)
CY04 *                         + B(I-1,1)*M(3)
CY04        T4 = ISHFT(T3,-15) + B(I-1,4)*M(1) + B(I-1,3)*M(2)
CY04 *                         + B(I-1,2)*M(3) + B(I-1,1)*M(4)
CY04        B(I,4) = IAND(T4,32767)
CY04        B(I,3) = IAND(T3,32767)
CY04        B(I,2) = IAND(T2,32767)
CY04        B(I,1) = IAND(T1,32767)
CY03        T1 = B(I-1,1)*M(1)
CY03        T2 = ISHFT(T1,-20) + B(I-1,2)*M(1) + B(I-1,1)*M(2)
CY03        T3 = ISHFT(T2,-20) + B(I-1,3)*M(1) + B(I-1,2)*M(2)
CY03 *                         + B(I-1,1)*M(3)
CY03        B(I,3) = IAND(T3,1048575)
CY03        B(I,2) = IAND(T2,1048575)
CY03        B(I,1) = IAND(T1,1048575)
CY02        T1 = B(I-1,1)*M(1)
CY02        T2 = ISHFT(T1,-30) + B(I-1,2)*M(1) + B(I-1,1)*M(2)
CY02        B(I,2) = IAND(T2,1073741823)
CY02        B(I,1) = IAND(T1,1073741823)
   20    CONTINUE
      ELSE
C
C        Generate next buffer of LV integers by multiplying in
C        parallel by M**LV modulo 2**59.
C
         DO 40 I = 1, LV
            V = B(I,1)*MLV(1)
            U = V/32768
            T1 = V - 32768*U
            V = U + B(I,2)*MLV(1) + B(I,1)*MLV(2)
            U = V/32768
            T2 = V - 32768*U
            V = U + B(I,3)*MLV(1) + B(I,2)*MLV(2) + B(I,1)*MLV(3)
            U = V/32768
            T3 = V - 32768*U
            V = U + B(I,4)*MLV(1) + B(I,3)*MLV(2) + B(I,2)*MLV(3)
     *            + B(I,1)*MLV(4)
            U = V/32768
            B(I,4) = V - 32768*U
            B(I,3) = T3
            B(I,2) = T2
            B(I,1) = T1
CX03        V = B(I,1)*MLV(1)
CX03        U = V/1048576
CX03        T1 = V - 1048576*U
CX03        V = U + B(I,2)*MLV(1) + B(I,1)*MLV(2)
CX03        U = V/1048576
CX03        T2 = V - 1048576*U
CX03        V = U + B(I,3)*MLV(1) + B(I,2)*MLV(2) + B(I,1)*MLV(3)
CX03        U = V/1048576
CX03        B(I,3) = V - 1048576*U
CX03        B(I,2) = T2
CX03        B(I,1) = T1
CX02        V = B(I,1)*MLV(1)
CX02        U = V/1073741824
CX02        T1 = V - 1073741824*U
CX02        V = U + B(I,2)*MLV(1) + B(I,1)*MLV(2)
CX02        U = V/1073741824
CX02        B(I,2) = V - 1073741824*U
CX02        B(I,1) = T1
CY04        T1 = B(I,1)*MLV(1)
CY04        T2 = ISHFT(T1,-15) + B(I,2)*MLV(1) + B(I,1)*MLV(2)
CY04        T3 = ISHFT(T2,-15) + B(I,3)*MLV(1) + B(I,2)*MLV(2)
CY04 *                         + B(I,1)*MLV(3)
CY04        T4 = ISHFT(T3,-15) + B(I,4)*MLV(1) + B(I,3)*MLV(2)
CY04 *                         + B(I,2)*MLV(3) + B(I,1)*MLV(4)
CY04        B(I,4) = IAND(T4,32767)
CY04        B(I,3) = IAND(T3,32767)
CY04        B(I,2) = IAND(T2,32767)
CY04        B(I,1) = IAND(T1,32767)
CY03        T1 = B(I,1)*MLV(1)
CY03        T2 = ISHFT(T1,-20) + B(I,2)*MLV(1) + B(I,1)*MLV(2)
CY03        T3 = ISHFT(T2,-20) + B(I,3)*MLV(1) + B(I,2)*MLV(2)
CY03 *                         + B(I,1)*MLV(3)
CY03        B(I,3) = IAND(T3,1048575)
CY03        B(I,2) = IAND(T2,1048575)
CY03        B(I,1) = IAND(T1,1048575)
CY02        T1 = B(I,1)*MLV(1)
CY02        T2 = ISHFT(T1,-30) + B(I,2)*MLV(1) + B(I,1)*MLV(2)
CY02        B(I,2) = IAND(T2,1073741823)
CY02        B(I,1) = IAND(T1,1073741823)
   40    CONTINUE
      END IF
C
C     Convert integers in B to real numbers in (0.0,1.0) stored in RV.
C
      DO 60 I = 1, LV
         RV(I) = MIN(ONEM,(B(I,4)*32768+B(I,3))*RP2
     *                     +(B(I,2)*32768+B(I,1))*RP1)
CX03     RV(I) = MIN(ONEM,(B(I,3)*1048576+B(I,2))*RP2 + B(I,1)*RP1)
CX02     RV(I) = MIN(ONEM,(B(I,2)*1073741824+B(I,1))*RP1)
CY04     RV(I) = MIN(ONEM,(ISHFT(B(I,4),15)+B(I,3))*RP2
CY04 *                     +(ISHFT(B(I,2),15)+B(I,1))*RP1)
CY03     RV(I) = MIN(ONEM,(ISHFT(B(I,3),20)+B(I,2))*RP2 + B(I,1)*RP1)
CY02     RV(I) = MIN(ONEM,(ISHFT(B(I,2),30)+B(I,1))*RP1)
   60 CONTINUE
      KV = 0
C
      RETURN
      END

      DOUBLE PRECISION FUNCTION D01AHZ(S1,S3,AL,AR)
C     MARK 8 RELEASE. NAG COPYRIGHT 1979.
C     MARK 11.5(F77) REVISED. (SEPT 1985.)
C
C     SUBDIVIDE IN RATIO 1/2 IF INTEGRAND IS STEEPER ON LEFT OR
C                        2/1 IF STEEPER ON RIGHT
C                        1/1 OTHERWISE
C
C     .. Scalar Arguments ..
      DOUBLE PRECISION                 AL, AR, S1, S3
C     .. Executable Statements ..
      IF (AL-AR) 20, 40, 60
   20 D01AHZ = (S1+2.0D0*S3)/3.0D0
      RETURN
   40 D01AHZ = (S1+S3)/2.0D0
      RETURN
   60 D01AHZ = (2.0D0*S1+S3)/3.0D0
      RETURN
      END

      SUBROUTINE D01AJF(F,A,B,EPSABS,EPSREL,RESULT,ABSERR,WORK,LWORK,
     *                  IWORK,LIWORK,IFAIL)
C     MARK 13 RE-ISSUE. NAG COPYRIGHT 1988.
C
C     D01AJF IS A GENERAL PURPOSE INTEGRATOR WHICH CALCULATES
C     AN APPROXIMATION TO THE INTEGRAL OF A FUNCTION OVER A FINITE
C     INTERVAL (A,B)
C
C     D01AJF ITSELF IS ESSENTIALLY A DUMMY ROUTINE WHOSE FUNCTION IS TO
C     PARTITION THE WORK ARRAYS WORK AND IWORK FOR USE BY D01AJV.
C     WORK IS PARTITIONED INTO 4 ARRAYS EACH OF SIZE LIMIT, WHERE
C     LIMIT = MIN(LWORK/4, LIWORK).
C     IWORK IS A SINGLE ARRAY IN D01AJV OF SIZE LIMIT.
C
C     .. Parameters ..
      DOUBLE PRECISION  ZERO
      PARAMETER         (ZERO=0.0D0)
      CHARACTER*6       SRNAME
      PARAMETER         (SRNAME='D01AJF')
C     .. Scalar Arguments ..
      DOUBLE PRECISION  A, ABSERR, B, EPSABS, EPSREL, RESULT
      INTEGER           IFAIL, LIWORK, LWORK
C     .. Array Arguments ..
      DOUBLE PRECISION  WORK(LWORK)
      INTEGER           IWORK(LIWORK)
C     .. Function Arguments ..
      DOUBLE PRECISION  F
      EXTERNAL          F
C     .. Local Scalars ..
      INTEGER           I, IBL, IEL, IER, IERR, IRL, J, JBL, JEL, JRL,
     *                  K, LAST, LIMIT, NEVAL, NREC
      CHARACTER*1       ORDER
C     .. Local Arrays ..
      CHARACTER*80      REC(2)
C     .. External Functions ..
      INTEGER           P01ABF
      EXTERNAL          P01ABF
C     .. External Subroutines ..
      EXTERNAL          D01AJV, M01DAF, M01EAF
C     .. Intrinsic Functions ..
      INTRINSIC         ABS, MIN
C     .. Executable Statements ..
      IER = IFAIL
C     CHECK THAT MINIMUM WORKSPACE REQUIREMENTS ARE MET
      IF (LWORK.LT.4 .OR. LIWORK.LT.1) GO TO 100
C     LIMIT - UPPER BOUND ON NUMBER OF SUBINTERVALS
      LIMIT = MIN(LWORK/4,LIWORK)
C     SET UP BASE ADDRESSES FOR WORK ARRAYS
      IBL = LIMIT + 1
      IEL = LIMIT + IBL
      IRL = LIMIT + IEL
C     PERFORM INTEGRATION
      CALL D01AJV(F,A,B,ABS(EPSABS),ABS(EPSREL),WORK(1),WORK(IBL),
     *            WORK(IEL),WORK(IRL),LIMIT,IWORK,LIMIT,RESULT,ABSERR,
     *            NEVAL,IER)
C     RE-ORDER THE ELEMENTS OF WORK SO THAT THE RIGHT END-POINTS OF THE
C     SUB-INTERVALS (BLIST), ABSOLUTE ERROR ESTIMATES (ELIST) AND
C     APPROXIMATIONS TO THE INTEGRAL OVER THE SUB-INTERVALS (RLIST)
C     ARE EASILY ACCESSIBLE TO THE USER (SEE D01AJV).
      LAST = IWORK(1)
      IF (IER.LT.6 .AND. LAST.GE.1) THEN
         JBL = LAST
         JEL = 2*LAST
         JRL = 3*LAST
         IF (LAST.LT.LIMIT) THEN
            DO 20 I = 1, LAST
               WORK(JBL+I) = WORK(IBL+I-1)
   20       CONTINUE
            DO 40 I = 1, LAST
               WORK(JEL+I) = WORK(IEL+I-1)
   40       CONTINUE
            DO 60 I = 1, LAST
               WORK(JRL+I) = WORK(IRL+I-1)
   60       CONTINUE
         END IF
C        ZERO THE REMAINING PART OF WORK
         K = 4*LAST + 1
         DO 80 J = K, LWORK
            WORK(J) = ZERO
   80    CONTINUE
C        SORT THE ELEMENTS OF ALIST INTO ASCENDING ORDER USING M01DAF
C        AND M01EAF. ON EXIT FROM M01DAF, IWORK(1), ... ,IWORK(LAST)
C        CONTAIN THE RANKS OF ALIST(1), ... ,ALIST(LAST).
         IERR = 0
         ORDER = 'A'
         CALL M01DAF(WORK(1),1,LAST,ORDER,IWORK,IERR)
         CALL M01EAF(WORK(1),1,LAST,IWORK,IERR)
C        USE IWORK(1), ... ,IWORK(LAST) TO RECOVER THE VALUES OF
C        BLIST(I), ELIST(I) AND RLIST(I) CORRESPONDING TO ALIST(I)
C        AS RETURNED BY M01EAF, WHERE I = 1, 2, ...,LAST.
         JBL = JBL + 1
         CALL M01EAF(WORK(JBL),1,LAST,IWORK,IERR)
         JEL = JEL + 1
         CALL M01EAF(WORK(JEL),1,LAST,IWORK,IERR)
         JRL = JRL + 1
         CALL M01EAF(WORK(JRL),1,LAST,IWORK,IERR)
         IWORK(1) = LAST
      END IF
      IF (IER.NE.0) GO TO 120
      IFAIL = 0
      GO TO 140
C     ERROR 6 = INSUFFICIENT WORKSPACE
  100 IER = 6
      WRITE (REC,FMT=99999) LWORK, LIWORK
  120 NREC = 2
      IF (IER.EQ.1) THEN
         WRITE (REC,FMT=99998) LIMIT, LWORK, LIWORK
      ELSE IF (IER.EQ.2) THEN
         WRITE (REC,FMT=99997) EPSABS, EPSREL
      ELSE IF (IER.EQ.3) THEN
         NREC = 0
      ELSE IF (IER.EQ.4) THEN
         WRITE (REC(1),FMT=99996)
         NREC = 1
      ELSE IF (IER.EQ.5) THEN
         WRITE (REC(1),FMT=99995)
         NREC = 1
      END IF
      IFAIL = P01ABF(IFAIL,IER,SRNAME,NREC,REC)
  140 RETURN
C
99999 FORMAT (' ** On entry, LW.lt.4 or LIW.lt.1:',/'    LW = ',I16,
     *       '  LIW = ',I16)
99998 FORMAT (' ** The maximum number of subdivisions (LIMIT) has been',
     *       ' reached:',/'    LIMIT = ',I16,'   LW = ',I16,'   LIW = ',
     *       I16)
99997 FORMAT (' ** Round-off error prevents the requested tolerance fr',
     *       'om being achieved:',/'    EPSABS = ',1P,D8.1,
     *       '  EPSREL = ',1P,D8.1)
99996 FORMAT (' ** Round-off error is detected in the extrapolation ta',
     *       'ble')
99995 FORMAT (' ** The integral is probably divergent or slowly conver',
     *       'gent')
      END

      SUBROUTINE D01AJV(F,A,B,EPSABS,EPSREL,ALIST,BLIST,ELIST,RLIST,
     *                  LIMIT,IORD,LIORD,RESULT,ABSERR,NEVAL,IER)
C     MARK 13 RE-ISSUE. NAG COPYRIGHT 1988.
C     BASED ON QUADPACK ROUTINE  QAGS.
C     ..................................................................
C
C        PURPOSE
C           THE ROUTINE CALCULATES AN APPROXIMATION  RESULT  TO A GIVEN
C           DEFINITE INTEGRAL   I = INTEGRAL OF  F  OVER (A,B),
C           HOPEFULLY SATISFYING FOLLOWING CLAIM FOR ACCURACY
C           ABS(I-RESULT).LE.MAX(EPSABS,EPSREL*ABS(I)).
C
C        PARAMETERS
C         ON ENTRY
C            F      - REAL
C                     FUNCTION SUBPROGRAM DEFINING THE INTEGRAND
C                     FUNCTION F(X). THE ACTUAL NAME FOR F NEEDS TO BE
C                     DECLARED E X T E R N A L IN THE DRIVER PROGRAM.
C
C            A      - REAL
C                     LOWER LIMIT OF INTEGRATION
C
C            B      - REAL
C                     UPPER LIMIT OF INTEGRATION
C
C            EPSABS - REAL
C                     ABSOLUTE ACCURACY REQUESTED
C            EPSREL - REAL
C                     RELATIVE ACCURACY REQUESTED
C
C            ALIST,BLIST,ELIST,RLIST
C                   - REAL WORK ARRAYS (FUNCTIONS DESCRIBED BELOW)
C
C            LIMIT  - INTEGER
C                     GIVES AN UPPERBOUND ON THE NUMBER OF SUBINTERVALS
C                     IN THE PARTITION OF (A,B), LIMIT.GE.1.
C
C            IORD   - INTEGER
C                     WORK ARRAY OF DIMENSION LIORD
C
C            LIORD  - INTEGER
C                     LENGTH OF IORD (=LIMIT)
C
C         ON RETURN
C            RESULT - REAL
C                     APPROXIMATION TO THE INTEGRAL
C
C            ABSERR - REAL
C                     ESTIMATE OF THE MODULUS OF THE ABSOLUTE ERROR,
C                     WHICH SHOULD EQUAL OR EXCEED ABS(I-RESULT)
C
C            NEVAL  - INTEGER
C                     NUMBER OF INTEGRAND EVALUATIONS
C
C            IER    - INTEGER
C                     IER = 0 NORMAL AND RELIABLE TERMINATION OF THE
C                             ROUTINE. IT IS ASSUMED THAT THE REQUESTED
C                             ACCURACY HAS BEEN ACHIEVED.
C                     IER.GT.0 ABNORMAL TERMINATION OF THE ROUTINE
C                             THE ESTIMATES FOR INTEGRAL AND ERROR ARE
C                             LESS RELIABLE. IT IS ASSUMED THAT THE
C                             REQUESTED ACCURACY HAS NOT BEEN ACHIEVED.
C                         = 1 MAXIMUM NUMBER OF SUBDIVISIONS ALLOWED
C                             HAS BEEN ACHIEVED. ONE CAN ALLOW MORE SUB-
C                             DIVISIONS BY INCREASING THE DATA VALUE OF
C                             LIMIT IN D01AJV (AND TAKING THE ACCORDING
C                             DIMENSION ADJUSTMENTS INTO ACCOUNT).
C                             HOWEVER, IF THIS YIELDS NO IMPROVEMENT
C                             IT IS ADVISED TO ANALYZE THE INTEGRAND
C                             IN ORDER TO DETERMINE THE INTEGRATION
C                             DIFFICULTIES. IF THE POSITION OF A
C                             LOCAL DIFFICULTY CAN BE DETERMINED (E.G.
C                             SINGULARITY, DISCONTINUITY WITHIN THE
C                             INTERVAL) ONE WILL PROBABLY GAIN FROM
C                             SPLITTING UP THE INTERVAL AT THIS POINT
C                             AND CALLING THE INTEGRATOR ON THE SUB-
C                             RANGES. IF POSSIBLE, AN APPROPRIATE
C                             SPECIAL-PURPOSE INTEGRATOR SHOULD BE USED,
C                             WHICH IS DESIGNED FOR HANDLING THE TYPE
C                             OF DIFFICULTY INVOLVED.
C                         = 2 THE OCCURRENCE OF ROUNDOFF ERROR IS DETEC-
C                             TED, WHICH PREVENTS THE REQUESTED
C                             TOLERANCE FROM BEING ACHIEVED.
C                             THE ERROR MAY BE UNDER-ESTIMATED.
C                         = 3 EXTREMELY BAD INTEGRAND BEHAVIOUR OCCURS
C                             AT SOME  POINTS OF THE INTEGRATION
C                             INTERVAL.
C                         = 4 THE ALGORITHM DOES NOT CONVERGE. ROUNDOFF
C                             ERROR IS DETECTED IN THE EXTRAPOLATION
C                             TABLE. IT IS PRESUMED THAT THE REQUESTED
C                             TOLERANCE CANNOT BE ACHIEVED, AND THAT THE
C                             RETURNED RESULT IS THE BEST WHICH CAN BE
C                             OBTAINED.
C                         = 5 THE INTEGRAL IS PROBABLY DIVERGENT, OR
C                             SLOWLY CONVERGENT. IT MUST BE NOTED THAT
C                             DIVERGENCE CAN OCCUR WITH ANY OTHER VALUE
C                             OF IER.
C     ..................................................................
C
C     .. Scalar Arguments ..
      DOUBLE PRECISION  A, ABSERR, B, EPSABS, EPSREL, RESULT
      INTEGER           IER, LIMIT, LIORD, NEVAL
C     .. Array Arguments ..
      DOUBLE PRECISION  ALIST(LIMIT), BLIST(LIMIT), ELIST(LIMIT),
     *                  RLIST(LIMIT)
      INTEGER           IORD(LIORD)
C     .. Function Arguments ..
      DOUBLE PRECISION  F
      EXTERNAL          F
C     .. Local Scalars ..
      DOUBLE PRECISION  A1, A2, ABSEPS, AREA, AREA1, AREA12, AREA2, B1,
     *                  B2, CORREC, DEFAB1, DEFAB2, DEFABS, DRES,
     *                  EPMACH, ERLARG, ERLAST, ERRBND, ERRMAX, ERRO12,
     *                  ERROR1, ERROR2, ERRSUM, ERTEST, OFLOW, RESABS,
     *                  RESEPS, SMALL, UFLOW
      INTEGER           ID, IERRO, IERS, IROFF1, IROFF2, IROFF3, JUPBND,
     *                  K, KSGN, KTMIN, LAST, MAXERR, NERR, NRES, NRMAX,
     *                  NUMRL2
      LOGICAL           EXTRAP, NOEXT
C     .. Local Arrays ..
      DOUBLE PRECISION  RES3LA(3), RLIST2(52)
      CHARACTER*80      REC(2)
C     .. External Functions ..
      DOUBLE PRECISION  X02AJF, X02AMF
      EXTERNAL          X02AJF, X02AMF
C     .. External Subroutines ..
      EXTERNAL          D01AJX, D01AJY, D01AJZ, X04AAF, X04BAF
C     .. Intrinsic Functions ..
      INTRINSIC         ABS, MAX
C     .. Executable Statements ..
C
C            THE DIMENSION OF RLIST2 IS DETERMINED BY THE VALUE OF
C            LIMEXP IN SUBROUTINE D01AJY (RLIST2 SHOULD BE OF DIMENSION
C            (LIMEXP+2) AT LEAST).
C
C            LIST OF MAJOR VARIABLES
C            -----------------------
C
C           ALIST     - LIST OF LEFT END POINTS OF ALL SUBINTERVALS
C                       CONSIDERED UP TO NOW
C           BLIST     - LIST OF RIGHT END POINTS OF ALL SUBINTERVALS
C                       CONSIDERED UP TO NOW
C           RLIST(I)  - APPROXIMATION TO THE INTEGRAL OVER
C                       (ALIST(I),BLIST(I))
C           RLIST2    - ARRAY OF DIMENSION AT LEAST LIMEXP+2 CONTAINING
C                       THE PART OF THE EPSILON TABLE WHICH IS STILL
C                       NEEDED FOR FURTHER COMPUTATIONS
C           ELIST(I)  - ERROR ESTIMATE APPLYING TO RLIST(I)
C           MAXERR    - POINTER TO THE INTERVAL WITH LARGEST ERROR
C                       ESTIMATE
C           ERRMAX    - ELIST(MAXERR)
C           ERLAST    - ERROR ON THE INTERVAL CURRENTLY SUBDIVIDED
C                       (BEFORE THAT SUBDIVISION HAS TAKEN PLACE)
C           AREA      - SUM OF THE INTEGRALS OVER THE SUBINTERVALS
C           ERRSUM    - SUM OF THE ERRORS OVER THE SUBINTERVALS
C           ERRBND    - REQUESTED ACCURACY MAX(EPSABS,EPSREL*
C                       ABS(RESULT))
C           *****1    - VARIABLE FOR THE LEFT INTERVAL
C           *****2    - VARIABLE FOR THE RIGHT INTERVAL
C           LAST      - INDEX FOR SUBDIVISION
C           NRES      - NUMBER OF CALLS TO THE EXTRAPOLATION ROUTINE
C           NUMRL2    - NUMBER OF ELEMENTS CURRENTLY IN RLIST2. IF AN
C                       APPROPRIATE APPROXIMATION TO THE COMPOUNDED
C                       INTEGRAL HAS BEEN OBTAINED IT IS PUT IN
C                       RLIST2(NUMRL2) AFTER NUMRL2 HAS BEEN INCREASED
C                       BY ONE.
C           SMALL     - LENGTH OF THE SMALLEST INTERVAL CONSIDERED
C                       UP TO NOW, MULTIPLIED BY 1.5
C           ERLARG    - SUM OF THE ERRORS OVER THE INTERVALS LARGER
C                       THAN THE SMALLEST INTERVAL CONSIDERED UP TO NOW
C           EXTRAP    - LOGICAL VARIABLE DENOTING THAT THE ROUTINE IS
C                       ATTEMPTING TO PERFORM EXTRAPOLATION I.E. BEFORE
C                       SUBDIVIDING THE SMALLEST INTERVAL WE TRY TO
C                       DECREASE THE VALUE OF ERLARG.
C           NOEXT     - LOGICAL VARIABLE DENOTING THAT EXTRAPOLATION
C                       IS NO LONGER ALLOWED (TRUE VALUE)
C
      EPMACH = X02AJF()
      UFLOW = X02AMF()
      OFLOW = 1.0D+00/UFLOW
C
C            TEST ON VALIDITY OF PARAMETERS
C            ------------------------------
      IERS = IER
      IER = 0
      NEVAL = 0
      LAST = 0
      RESULT = 0.0D+00
      ABSERR = 0.0D+00
      ALIST(1) = A
      BLIST(1) = B
      RLIST(1) = 0.0D+00
      ELIST(1) = 0.0D+00
C
C           FIRST APPROXIMATION TO THE INTEGRAL
C           -----------------------------------
C
      IERRO = 0
      CALL D01AJZ(F,A,B,RESULT,ABSERR,DEFABS,RESABS)
C
C           TEST ON ACCURACY.
C
      DRES = ABS(RESULT)
      ERRBND = MAX(EPSABS,EPSREL*DRES)
      LAST = 1
      RLIST(1) = RESULT
      ELIST(1) = ABSERR
      IORD(1) = 1
      IF ((ABSERR.LE.ERRBND .AND. ABSERR.NE.RESABS)
     *    .OR. ABSERR.EQ.0.0D+00) GO TO 340
      IF (LIMIT.EQ.1) IER = 1
      IF (ABSERR.LE.1.0D+02*EPMACH*DEFABS .AND. ABSERR.GT.ERRBND)
     *    IER = 2
      IF (IER.NE.0) GO TO 340
C
C           INITIALIZATION
C           --------------
C
      RLIST2(1) = RESULT
      ERRMAX = ABSERR
      MAXERR = 1
      AREA = RESULT
      ERRSUM = ABSERR
      ABSERR = OFLOW
      NRMAX = 1
      NRES = 0
      NUMRL2 = 2
      KTMIN = 0
      EXTRAP = .FALSE.
      NOEXT = .FALSE.
      IROFF1 = 0
      IROFF2 = 0
      IROFF3 = 0
      KSGN = -1
      IF (DRES.GE.(1.0D+00-5.0D+01*EPMACH)*DEFABS) KSGN = 1
C
C           MAIN DO-LOOP
C           ------------
C
      DO 200 LAST = 2, LIMIT
C
C           BISECT THE SUBINTERVAL WITH THE NRMAX-TH LARGEST ERROR
C           ESTIMATE.
C
         A1 = ALIST(MAXERR)
         B1 = 5.0D-01*(ALIST(MAXERR)+BLIST(MAXERR))
         A2 = B1
         B2 = BLIST(MAXERR)
         ERLAST = ERRMAX
         CALL D01AJZ(F,A1,B1,AREA1,ERROR1,RESABS,DEFAB1)
         CALL D01AJZ(F,A2,B2,AREA2,ERROR2,RESABS,DEFAB2)
C
C           IMPROVE PREVIOUS APPROXIMATIONS TO INTEGRAL AND ERROR
C           AND TEST FOR ACCURACY.
C
         AREA12 = AREA1 + AREA2
         ERRO12 = ERROR1 + ERROR2
         ERRSUM = ERRSUM + ERRO12 - ERRMAX
         AREA = AREA + AREA12 - RLIST(MAXERR)
         IF (DEFAB1.EQ.ERROR1 .OR. DEFAB2.EQ.ERROR2) GO TO 40
         IF (ABS(RLIST(MAXERR)-AREA12).GT.1.0D-05*ABS(AREA12)
     *       .OR. ERRO12.LT.9.9D-01*ERRMAX) GO TO 20
         IF (EXTRAP) IROFF2 = IROFF2 + 1
         IF ( .NOT. EXTRAP) IROFF1 = IROFF1 + 1
   20    IF (LAST.GT.10 .AND. ERRO12.GT.ERRMAX) IROFF3 = IROFF3 + 1
   40    RLIST(MAXERR) = AREA1
         RLIST(LAST) = AREA2
         ERRBND = MAX(EPSABS,EPSREL*ABS(AREA))
C
C           APPEND THE NEWLY-CREATED INTERVALS TO THE LIST.
C
         IF (ERROR2.GT.ERROR1) GO TO 60
         ALIST(LAST) = A2
         BLIST(MAXERR) = B1
         BLIST(LAST) = B2
         ELIST(MAXERR) = ERROR1
         ELIST(LAST) = ERROR2
         GO TO 80
   60    ALIST(MAXERR) = A2
         ALIST(LAST) = A1
         BLIST(LAST) = B1
         RLIST(MAXERR) = AREA2
         RLIST(LAST) = AREA1
         ELIST(MAXERR) = ERROR2
         ELIST(LAST) = ERROR1
C
C           CALL SUBROUTINE D01AJX TO MAINTAIN THE DESCENDING ORDERING
C           IN THE LIST OF ERROR ESTIMATES AND SELECT THE SUBINTERVAL
C           WITH NRMAX-TH LARGEST ERROR ESTIMATE (TO BE BISECTED NEXT).
C
   80    CALL D01AJX(LIMIT,LAST,MAXERR,ERRMAX,ELIST,IORD,NRMAX)
C        ***JUMP OUT OF DO-LOOP
         IF (ERRSUM.LE.ERRBND) GO TO 280
C
C           SET ERROR FLAG IN THE CASE THAT THE NUMBER OF SUBINTERVALS
C           EQUALS LIMIT.
C
         IF (LAST.EQ.LIMIT) IER = 1
C
C           TEST FOR ROUNDOFF ERROR AND EVENTUALLY SET ERROR FLAG.
C
         IF (IROFF1+IROFF2.GE.10 .OR. IROFF3.GE.20) IER = 2
         IF (IROFF2.GE.5) IERRO = 3
C
C           SET ERROR FLAG IN THE CASE OF BAD INTEGRAND BEHAVIOUR
C           AT A POINT OF THE INTEGRATION RANGE.
C
         IF (MAX(ABS(A1),ABS(B2)).LE.(1.0D+00+1.0D+03*EPMACH)*(ABS(A2)
     *       +1.0D+03*UFLOW)) IER = 4
C        ***JUMP OUT OF DO-LOOP
         IF (IER.GT.1) GO TO 220
         IF (LAST.EQ.2) GO TO 180
         IF (NOEXT) GO TO 200
         ERLARG = ERLARG - ERLAST
         IF (ABS(B1-A1).GT.SMALL) ERLARG = ERLARG + ERRO12
         IF (EXTRAP) GO TO 100
C
C           TEST WHETHER THE INTERVAL TO BE BISECTED NEXT IS THE
C           SMALLEST INTERVAL.
C
         IF (ABS(BLIST(MAXERR)-ALIST(MAXERR)).GT.SMALL) GO TO 200
         EXTRAP = .TRUE.
         NRMAX = 2
  100    IF (IERRO.EQ.3 .OR. ERLARG.LE.ERTEST) GO TO 140
C
C           THE SMALLEST INTERVAL HAS THE LARGEST ERROR.
C           BEFORE BISECTING DECREASE THE SUM OF THE ERRORS OVER THE
C           LARGER INTERVALS (ERLARG) AND PERFORM EXTRAPOLATION.
C
         ID = NRMAX
         JUPBND = LAST
         IF (LAST.GT.(2+LIMIT/2)) JUPBND = LIMIT + 3 - LAST
         DO 120 K = ID, JUPBND
            MAXERR = IORD(NRMAX)
            ERRMAX = ELIST(MAXERR)
C           ***JUMP OUT OF DO-LOOP
            IF (ABS(BLIST(MAXERR)-ALIST(MAXERR)).GT.SMALL) GO TO 200
            NRMAX = NRMAX + 1
  120    CONTINUE
C
C           PERFORM EXTRAPOLATION.
C
  140    NUMRL2 = NUMRL2 + 1
         RLIST2(NUMRL2) = AREA
         CALL D01AJY(NUMRL2,RLIST2,RESEPS,ABSEPS,RES3LA,NRES)
         KTMIN = KTMIN + 1
         IF (KTMIN.GT.5 .AND. ABSERR.LT.1.0D-03*ERRSUM) IER = 5
         IF (ABSEPS.GE.ABSERR) GO TO 160
         KTMIN = 0
         ABSERR = ABSEPS
         RESULT = RESEPS
         CORREC = ERLARG
         ERTEST = MAX(EPSABS,EPSREL*ABS(RESEPS))
C        ***JUMP OUT OF DO-LOOP
         IF (ABSERR.LE.ERTEST) THEN
            IF (IER.EQ.1) IER = 0
            GO TO 220
         END IF
C
C           PREPARE BISECTION OF THE SMALLEST INTERVAL.
C
  160    IF (NUMRL2.EQ.1) NOEXT = .TRUE.
         IF (IER.EQ.5 .OR. IER.EQ.1) GO TO 220
         MAXERR = IORD(1)
         ERRMAX = ELIST(MAXERR)
         NRMAX = 1
         EXTRAP = .FALSE.
         SMALL = SMALL*5.0D-01
         ERLARG = ERRSUM
         GO TO 200
  180    SMALL = ABS(B-A)*3.75D-01
         ERLARG = ERRSUM
         ERTEST = ERRBND
         RLIST2(2) = AREA
  200 CONTINUE
      LAST = LIMIT
C
C           SET FINAL RESULT AND ERROR ESTIMATE.
C           ------------------------------------
C
  220 IF (ABSERR.EQ.OFLOW) GO TO 280
      IF (IER+IERRO.EQ.0) GO TO 260
      IF (IERRO.EQ.3) ABSERR = ABSERR + CORREC
      IF (IER.EQ.0) IER = 3
      IF (RESULT.NE.0.0D+00 .AND. AREA.NE.0.0D+00) GO TO 240
      IF (ABSERR.GT.ERRSUM) GO TO 280
      IF (AREA.EQ.0.0D+00) GO TO 320
      GO TO 260
  240 IF (ABSERR/ABS(RESULT).GT.ERRSUM/ABS(AREA)) GO TO 280
C
C           TEST ON DIVERGENCE.
C
  260 IF (KSGN.EQ.(-1) .AND. MAX(ABS(RESULT),ABS(AREA))
     *    .LE.DEFABS*1.0D-02) GO TO 320
      IF (1.0D-02.GT.(RESULT/AREA) .OR. (RESULT/AREA)
     *    .GT.1.0D+02 .OR. ERRSUM.GT.ABS(AREA)) IER = 6
      GO TO 320
C
C           COMPUTE GLOBAL INTEGRAL SUM.
C
  280 RESULT = 0.0D+00
      DO 300 K = 1, LAST
         RESULT = RESULT + RLIST(K)
  300 CONTINUE
      ABSERR = ERRSUM
  320 IF (IER.GT.2) IER = IER - 1
  340 NEVAL = 42*LAST - 21
      IORD(1) = LAST
      IF (IER.EQ.3 .AND. IERS.NE.1) THEN
         CALL X04AAF(0,NERR)
         WRITE (REC,FMT=99999) A1, B2
         CALL X04BAF(NERR,REC(1))
         CALL X04BAF(NERR,REC(2))
      END IF
      RETURN
C
99999 FORMAT (' ** Extremely bad integrand behaviour occurs around the',
     *       ' subinterval',/'    (',1P,D15.7,' , ',1P,D15.7,' )')
      END
      SUBROUTINE M01DAF(RV,M1,M2,ORDER,IRANK,IFAIL)
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C
C     M01DAF RANKS A VECTOR OF REAL NUMBERS IN ASCENDING
C     OR DESCENDING ORDER.
C
C     M01DAF USES A VARIANT OF LIST-MERGING, AS DESCRIBED
C     BY KNUTH. THE ROUTINE TAKES ADVANTAGE OF NATURAL
C     ORDERING IN THE DATA, AND USES A SIMPLE LIST INSERTION
C     IN A PREPARATORY PASS TO GENERATE ORDERED LISTS OF
C     LENGTH AT LEAST 10. THE RANKING IS STABLE: EQUAL ELEMENTS
C     PRESERVE THEIR ORDERING IN THE INPUT DATA.
C
C     THE MINIMUM LENGTH OF THE LISTS AT THE END OF THE
C     PREPARATORY PASS IS DEFINED BY THE VARIABLE MAXINS.
C
C     WRITTEN BY N.M.MACLAREN, UNIVERSITY OF CAMBRIDGE.
C     REVISED BY NAG CENTRAL OFFICE.
C
C     .. Parameters ..
      CHARACTER*6       SRNAME
      PARAMETER         (SRNAME='M01DAF')
      INTEGER           MAXINS
      PARAMETER         (MAXINS=10)
C     .. Scalar Arguments ..
      INTEGER           IFAIL, M1, M2
      CHARACTER*1       ORDER
C     .. Array Arguments ..
      DOUBLE PRECISION  RV(M2)
      INTEGER           IRANK(M2)
C     .. Local Scalars ..
      DOUBLE PRECISION  A, B, C
      INTEGER           I, I1, I2, IERR, ILIST, J, J1, J2, K, K1, K2, L,
     *                  LIST1, LIST2, NLAST, NPREV, NREC
C     .. Local Arrays ..
      CHARACTER*80      P01REC(2)
C     .. External Functions ..
      INTEGER           P01ABF
      EXTERNAL          P01ABF
C     .. Executable Statements ..
C
C       CHECK THE ARGUMENTS AND DEAL WITH THE TRIVIAL CASE.
C
      IF (M2.LT.1 .OR. M1.LT.1 .OR. M1.GT.M2) THEN
         IERR = 1
         WRITE (P01REC,FMT=99999) M1, M2
         NREC = 2
      ELSE IF (ORDER.NE.'A' .AND. ORDER.NE.'a' .AND. ORDER.NE.'D' .AND.
     *         ORDER.NE.'d') THEN
         IERR = 2
         WRITE (P01REC,FMT=99998) ORDER
         NREC = 1
      ELSE IF (M1.EQ.M2) THEN
         IRANK(M2) = M2
         IERR = 0
      ELSE
         IERR = 0
C
C        INITIALISE, USING NATURAL RUNS IN BOTH DIRECTIONS AND
C        STRAIGHT LIST INSERTION FOR SMALL LISTS.
C
C        I  POINTS TO THE SMALLEST ELEMENT IN THE CURRENT LIST
C        J  POINTS TO THE LARGEST  ELEMENT IN THE CURRENT LIST
C        B  IS THE VALUE OF THE SMALLEST ELEMENT IN CURRENT LIST
C        C  IS THE VALUE OF THE LARGEST  ELEMENT IN CURRENT LIST
C
         ILIST = -1
         K = M1
         I = K
         J = K
         L = K + MAXINS
         B = RV(K)
         C = B
         DO 40 K = M1 + 1, M2
C
C           DEAL WITH ADDITIONS AT EITHER END.
C
            A = RV(K)
            IF (A.GE.C) THEN
               IRANK(J) = K
               J = K
               C = A
            ELSE IF (A.LT.B) THEN
               IRANK(K) = I
               I = K
               B = A
            ELSE
C
C              DO AN ASCENDING LIST INSERTION.
C
               IF (K.LT.L) THEN
                  I2 = I
   20             I1 = I2
                  I2 = IRANK(I1)
                  IF (A.GE.RV(I2)) GO TO 20
                  IRANK(I1) = K
                  IRANK(K) = I2
               ELSE
C
C                 ADD THE CURRENT LIST ON TO THE OTHERS.
C
                  IF (ILIST.LT.0) THEN
                     LIST1 = -I
                     ILIST = 0
                  ELSE IF (ILIST.EQ.0) THEN
                     LIST2 = -I
                     ILIST = 1
                     NPREV = NLAST
                  ELSE
                     IRANK(NPREV) = -I
                     NPREV = NLAST
                  END IF
C
                  NLAST = J
                  I = K
                  J = K
                  L = K + MAXINS
                  B = RV(K)
                  C = B
               END IF
            END IF
   40    CONTINUE
C
C        TIDY UP AT THE END.
C
         IRANK(J) = 0
         IF (ILIST.LT.0) THEN
            LIST1 = -I
            GO TO 280
         ELSE IF (ILIST.EQ.0) THEN
            LIST2 = -I
         ELSE
            IRANK(NPREV) = -I
         END IF
         IRANK(NLAST) = 0
C
C        AT THIS POINT:
C        LIST1 = - (INDEX OF LEAST ELEMENT IN THE FIRST LIST)
C        LIST2 = - (INDEX OF LEAST ELEMENT IN THE SECOND LIST)
C        FOR EACH K, IRANK(K) IS THE INDEX OF THE NEXT ELEMENT IN THE
C        CURRENT LIST, EXCEPT THAT, IF THERE IS NO SUCH ELEMENT,
C        IRANK(K) IS - (INDEX OF THE LEAST ELEMENT IN THE NEXT LIST
C        BUT 1)  OR 0 IF THERE IS NO SUCH LIST.
C
C        START MERGING LISTS BY PAIRS.
C
   60    ILIST = -1
         I = -LIST1
         J = -LIST2
   80    K = I
         IF (RV(I).GT.RV(J)) K = J
         IF (ILIST.LT.0) THEN
            LIST1 = -K
            ILIST = 0
         ELSE IF (ILIST.EQ.0) THEN
            LIST2 = -K
            ILIST = 1
            NLAST = L
         ELSE
            IRANK(NLAST) = -K
            NLAST = L
         END IF
C
C        MOVE ALONG THE LISTS UNTIL ONE FINISHES.
C
C        NEW VARIABLES I2, J2 AND K2 ARE USED INSTEAD OF I, J AND K
C        WITHIN THE INNERMOST BLOCK TO ENCOURAGE OPTIMISING COMPILERS TO
C        STORE THEM IN REGISTERS.
C         I2 POINTS TO THE CURRENT ELEMENT IN THE FIRST LIST
C         J2 POINTS TO THE CURRENT ELEMENT IN THE SECOND LIST
C         K2 POINTS TO THE CURRENT ELEMENT IN THE MERGED LIST
C
         I2 = I
         J2 = J
         IF (K.NE.I2) GO TO 140
  100    A = RV(J2)
         K2 = I2
  120    I2 = K2
         K2 = IRANK(I2)
         IF (K2.LE.0) GO TO 180
         IF (A.GE.RV(K2)) GO TO 120
         IRANK(I2) = J2
         I2 = K2
  140    A = RV(I2)
         K2 = J2
  160    J2 = K2
         K2 = IRANK(J2)
         IF (K2.LE.0) GO TO 200
         IF (A.GT.RV(K2)) GO TO 160
         IRANK(J2) = I2
         J2 = K2
         GO TO 100
C
C        ADD THE REMAINS OF ONE LIST TO THE OTHER.
C
  180    K = 1
         I1 = K2
         GO TO 220
  200    K = 2
         J1 = K2
  220    I = I2
         J = J2
         IF (K.EQ.1) THEN
C
C           FIRST LIST IS EXHAUSTED
C
            IRANK(I) = J
            I = -I1
            J1 = J
  240       J = J1
            J1 = IRANK(J)
            IF (J1.GT.0) GO TO 240
            L = J
            J = -J1
         ELSE
C
C           SECOND LIST IS EXHAUSTED
C
            IRANK(J) = I
            J = -J1
            I1 = I
  260       I = I1
            I1 = IRANK(I)
            IF (I1.GT.0) GO TO 260
            L = I
            I = -I1
         END IF
C
C        TIDY UP AND CARRY ON IF NOT FINISHED.
C
         IF ((I.NE.0) .AND. (J.NE.0)) GO TO 80
         IRANK(L) = 0
         K = I + J
         IF (ILIST.GT.0) THEN
            IRANK(NLAST) = -K
            GO TO 60
         ELSE IF (K.NE.0) THEN
            LIST2 = -K
            GO TO 60
         END IF
C
C        IF DESCENDING, REVERSE ALL POINTERS BETWEEN EQUALITY
C        BLOCKS.
C
  280    IF ((ORDER.EQ.'D') .OR. (ORDER.EQ.'d')) THEN
            I = 0
            J = -LIST1
  300       K = J
            K1 = K
            A = RV(K)
  320       K = K1
            K1 = IRANK(K)
            IF (K1.NE.0) THEN
               IF (A.EQ.RV(K1)) GO TO 320
            END IF
            IRANK(K) = I
            I = J
            J = K1
            IF (J.NE.0) GO TO 300
            LIST1 = -I
         END IF
C
C        CONVERT THE LIST FORM TO RANKS AND RETURN.
C
         K = M1
         I = -LIST1
  340    I1 = IRANK(I)
         IRANK(I) = K
         K = K + 1
         I = I1
         IF (I.GT.0) GO TO 340
C
      END IF
C
      IF (IERR.NE.0) THEN
         IFAIL = P01ABF(IFAIL,IERR,SRNAME,NREC,P01REC)
      ELSE
         IFAIL = 0
      END IF
      RETURN
C
99999 FORMAT (' ** On entry, one or more of the following parameter va',
     *  'lues is illegal',/'    M1 =',I16,'  M2 =',I16)
99998 FORMAT (' ** On entry, ORDER has an illegal value: ORDER = ',A1)
      END
      SUBROUTINE M01EAF(RV,M1,M2,IRANK,IFAIL)
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C
C     M01EAF RE-ARRANGES A VECTOR OF REAL NUMBERS INTO
C     THE ORDER SPECIFIED BY A VECTOR OF RANKS.
C
C     M01EAF IS DESIGNED TO BE USED TYPICALLY IN CONJUNCTION
C     WITH THE M01D- RANKING ROUTINES. AFTER ONE OF THE M01D-
C     ROUTINES HAS BEEN CALLED TO DETERMINE A VECTOR OF RANKS,
C     M01EAF CAN BE CALLED TO RE-ARRANGE A VECTOR OF REAL
C     NUMBERS INTO THE RANK ORDER. IF THE VECTOR OF RANKS HAS
C     BEEN GENERATED IN SOME OTHER WAY, THEN M01ZBF SHOULD BE
C     CALLED TO CHECK ITS VALIDITY BEFORE M01EAF IS CALLED.
C
C     WRITTEN BY N.M.MACLAREN, UNIVERSITY OF CAMBRIDGE.
C     REVISED BY NAG CENTRAL OFFICE.
C
C     .. Parameters ..
      CHARACTER*6       SRNAME
      PARAMETER         (SRNAME='M01EAF')
C     .. Scalar Arguments ..
      INTEGER           IFAIL, M1, M2
C     .. Array Arguments ..
      DOUBLE PRECISION  RV(M2)
      INTEGER           IRANK(M2)
C     .. Local Scalars ..
      DOUBLE PRECISION  A, B
      INTEGER           I, IERR, J, K
C     .. Local Arrays ..
      CHARACTER*80      P01REC(2)
C     .. External Functions ..
      INTEGER           P01ABF
      EXTERNAL          P01ABF
C     .. Intrinsic Functions ..
      INTRINSIC         ABS
C     .. Executable Statements ..
C
C       CHECK THE PARAMETERS AND MODIFY IRANK.
C
      IF (M2.LT.1 .OR. M1.LT.1 .OR. M1.GT.M2) THEN
         IERR = 1
         WRITE (P01REC,FMT=99999) M1, M2
      ELSE
         IERR = 0
         DO 20 I = M1, M2
            J = IRANK(I)
            IF ((J.LT.M1) .OR. (J.GT.M2)) GO TO 100
            IF (I.NE.J) IRANK(I) = -J
   20    CONTINUE
C
C        MOVE EACH NON-TRIVIAL CYCLE ROUND.
C
         DO 60 I = M1, M2
            K = -IRANK(I)
            IF (K.GE.0) THEN
               J = I
               A = RV(I)
   40          IRANK(J) = K
               B = RV(K)
               RV(K) = A
               J = K
               A = B
               K = -IRANK(J)
               IF (K.GT.0) GO TO 40
               IF (J.NE.I) GO TO 120
            END IF
   60    CONTINUE
      END IF
C
C       RETURN
C
   80 IF (IERR.NE.0) THEN
         IFAIL = P01ABF(IFAIL,IERR,SRNAME,2,P01REC)
      ELSE
         IFAIL = 0
      END IF
      RETURN
  100 IERR = 2
      WRITE (P01REC(2),FMT=99997) I, J
      GO TO 140
  120 IERR = 3
      WRITE (P01REC(2),FMT=99996) J
  140 WRITE (P01REC(1),FMT=99998)
C
C     RESTORE IRANK
C
      DO 160 J = M1, M2
         IRANK(J) = ABS(IRANK(J))
  160 CONTINUE
      GO TO 80
C
99999 FORMAT (' ** On entry, one or more of the following parameter va',
     *  'lues is illegal',/'    M1 =',I16,'  M2 =',I16)
99998 FORMAT (' ** IRANK(M1:M2) does not contain a permutation of the ',
     *  'integers M1 to M2')
99997 FORMAT ('    IRANK(',I6,') contains an out-of-range value',I16)
99996 FORMAT ('    IRANK contains a repeated value',I16)
      END
      SUBROUTINE D01AJX(LIMIT,LAST,MAXERR,ERMAX,ELIST,IORD,NRMAX)
C     MARK 13 RE-ISSUE. NAG COPYRIGHT 1988.
C     BASED ON QUADPACK ROUTINE  QSORT.
C     ..................................................................
C
C           PURPOSE
C              THIS ROUTINE MAINTAINS THE DESCENDING ORDERING IN THE
C              LIST OF THE LOCAL ERROR ESTIMATES RESULTING FROM THE
C              INTERVAL SUBDIVISION PROCESS. AT EACH CALL TWO ERROR
C              ESTIMATES ARE INSERTED USING THE SEQUENTIAL SEARCH
C              TOP-DOWN FOR THE LARGEST ERROR ESTIMATE AND BOTTOM-UP
C              FOR THE SMALLEST ERROR ESTIMATE.
C
C           PARAMETERS (MEANING AT OUTPUT)
C              LIMIT  - INTEGER
C                       MAXIMUM NUMBER OF ERROR ESTIMATES THE LIST CAN
C                       CONTAIN
C
C              LAST   - INTEGER
C                       NUMBER OF ERROR ESTIMATES CURRENTLY IN THE LIST
C
C              MAXERR - INTEGER
C                       MAXERR POINTS TO THE NRMAX-TH LARGEST ERROR
C                       ESTIMATE CURRENTLY IN THE LIST
C
C              ERMAX  - REAL
C                       NRMAX-TH LARGEST ERROR ESTIMATE
C                       ERMAX = ELIST(MAXERR)
C
C              ELIST  - REAL
C                       VECTOR OF DIMENSION LAST CONTAINING THE ERROR
C                       ESTIMATES
C
C              IORD   - INTEGER
C                       VECTOR OF DIMENSION LAST, THE FIRST K ELEMENTS
C                       OF WHICH CONTAIN POINTERS TO THE ERROR ESTIMATES
C                       SUCH THAT ELIST(IORD(1)),... , ELIST(IORD(K))
C                       FORM A DECREASING SEQUENCE, WITH
C                       K = LAST IF LAST.LE.(LIMIT/2+2), AND
C                       K = LIMIT+1-LAST OTHERWISE
C
C              NRMAX  - INTEGER
C                       MAXERR = IORD(NRMAX)
C
C     ..................................................................
C
C     .. Scalar Arguments ..
      DOUBLE PRECISION  ERMAX
      INTEGER           LAST, LIMIT, MAXERR, NRMAX
C     .. Array Arguments ..
      DOUBLE PRECISION  ELIST(LAST)
      INTEGER           IORD(LAST)
C     .. Local Scalars ..
      DOUBLE PRECISION  ERRMAX, ERRMIN
      INTEGER           I, IBEG, IDO, ISUCC, J, JBND, JUPBN, K
C     .. Executable Statements ..
C
C           CHECK WHETHER THE LIST CONTAINS MORE THAN TWO ERROR
C           ESTIMATES.
C
      IF (LAST.GT.2) GO TO 20
      IORD(1) = 1
      IORD(2) = 2
      GO TO 180
C
C           THIS PART OF THE ROUTINE IS ONLY EXECUTED IF, DUE TO A
C           DIFFICULT INTEGRAND, SUBDIVISION INCREASED THE ERROR
C           ESTIMATE. IN THE NORMAL CASE THE INSERT PROCEDURE SHOULD
C           START AFTER THE NRMAX-TH LARGEST ERROR ESTIMATE.
C
   20 ERRMAX = ELIST(MAXERR)
      IF (NRMAX.EQ.1) GO TO 60
      IDO = NRMAX - 1
      DO 40 I = 1, IDO
         ISUCC = IORD(NRMAX-1)
C        ***JUMP OUT OF DO-LOOP
         IF (ERRMAX.LE.ELIST(ISUCC)) GO TO 60
         IORD(NRMAX) = ISUCC
         NRMAX = NRMAX - 1
   40 CONTINUE
C
C           COMPUTE THE NUMBER OF ELEMENTS IN THE LIST TO BE MAINTAINED
C           IN DESCENDING ORDER. THIS NUMBER DEPENDS ON THE NUMBER OF
C           SUBDIVISIONS STILL ALLOWED.
C
   60 JUPBN = LAST
      IF (LAST.GT.(LIMIT/2+2)) JUPBN = LIMIT + 3 - LAST
      ERRMIN = ELIST(LAST)
C
C           INSERT ERRMAX BY TRAVERSING THE LIST TOP-DOWN, STARTING
C           COMPARISON FROM THE ELEMENT ELIST(IORD(NRMAX+1)).
C
      JBND = JUPBN - 1
      IBEG = NRMAX + 1
      IF (IBEG.GT.JBND) GO TO 100
      DO 80 I = IBEG, JBND
         ISUCC = IORD(I)
C        ***JUMP OUT OF DO-LOOP
         IF (ERRMAX.GE.ELIST(ISUCC)) GO TO 120
         IORD(I-1) = ISUCC
   80 CONTINUE
  100 IORD(JBND) = MAXERR
      IORD(JUPBN) = LAST
      GO TO 180
C
C           INSERT ERRMIN BY TRAVERSING THE LIST BOTTOM-UP.
C
  120 IORD(I-1) = MAXERR
      K = JBND
      DO 140 J = I, JBND
         ISUCC = IORD(K)
C        ***JUMP OUT OF DO-LOOP
         IF (ERRMIN.LT.ELIST(ISUCC)) GO TO 160
         IORD(K+1) = ISUCC
         K = K - 1
  140 CONTINUE
      IORD(I) = LAST
      GO TO 180
  160 IORD(K+1) = LAST
C
C           SET MAXERR AND ERMAX.
C
  180 MAXERR = IORD(NRMAX)
      ERMAX = ELIST(MAXERR)
      RETURN
      END
      SUBROUTINE D01AJY(N,EPSTAB,RESULT,ABSERR,RES3LA,NRES)
C     MARK 13 RE-ISSUE. NAG COPYRIGHT 1988.
C     BASED ON QUADPACK ROUTINE  QEXT.
C     ................................................................
C
C           PURPOSE
C              THE ROUTINE DETERMINES THE LIMIT OF A GIVEN SEQUENCE OF
C              APPROXIMATIONS, BY MEANS OF THE EPSILON ALGORITHM
C              OF P. WYNN.
C              AN ESTIMATE OF THE ABSOLUTE ERROR IS ALSO GIVEN.
C              THE CONDENSED EPSILON TABLE IS COMPUTED. ONLY THOSE
C              ELEMENTS NEEDED FOR THE COMPUTATION OF THE NEXT DIAGONAL
C              ARE PRESERVED.
C
C           PARAMETERS
C              N      - INTEGER
C                       EPSTAB(N) CONTAINS THE NEW ELEMENT IN THE
C                       FIRST COLUMN OF THE EPSILON TABLE.
C
C              EPSTAB - REAL
C                       VECTOR OF DIMENSION 52 CONTAINING THE ELEMENTS
C                       OF THE TWO LOWER DIAGONALS OF THE TRIANGULAR
C                       EPSILON TABLE
C                       THE ELEMENTS ARE NUMBERED STARTING AT THE
C                       RIGHT-HAND CORNER OF THE TRIANGLE.
C
C              RESULT - REAL
C                       RESULTING APPROXIMATION TO THE INTEGRAL
C
C              ABSERR - REAL
C                       ESTIMATE OF THE ABSOLUTE ERROR COMPUTED FROM
C                       RESULT AND THE 3 PREVIOUS RESULTS
C
C              RES3LA - REAL
C                       VECTOR OF DIMENSION 3 CONTAINING THE LAST 3
C                       RESULTS
C
C              NRES   - INTEGER
C                       NUMBER OF CALLS TO THE ROUTINE
C                       (SHOULD BE ZERO AT FIRST CALL)
C
C     ..................................................................
C
C     .. Scalar Arguments ..
      DOUBLE PRECISION  ABSERR, RESULT
      INTEGER           N, NRES
C     .. Array Arguments ..
      DOUBLE PRECISION  EPSTAB(52), RES3LA(3)
C     .. Local Scalars ..
      DOUBLE PRECISION  DELTA1, DELTA2, DELTA3, E0, E1, E1ABS, E2, E3,
     *                  EPMACH, EPSINF, ERR1, ERR2, ERR3, ERROR, OFLOW,
     *                  RES, SS, TOL1, TOL2, TOL3, UFLOW
      INTEGER           I, IB, IB2, IE, INDX, K1, K2, K3, LIMEXP,
     *                  NEWELM, NUM
C     .. External Functions ..
      DOUBLE PRECISION  X02AJF, X02AMF
      EXTERNAL          X02AJF, X02AMF
C     .. Intrinsic Functions ..
      INTRINSIC         ABS, MAX
C     .. Executable Statements ..
C
C           LIST OF MAJOR VARIABLES
C           -----------------------
C
C           E0     - THE 4 ELEMENTS ON WHICH THE
C           E1       COMPUTATION OF A NEW ELEMENT IN
C           E2       THE EPSILON TABLE IS BASED
C           E3                 E0
C                        E3    E1    NEW
C                              E2
C           NEWELM - NUMBER OF ELEMENTS TO BE COMPUTED IN THE NEW
C                    DIAGONAL
C           ERROR  - ERROR = ABS(E1-E0)+ABS(E2-E1)+ABS(NEW-E2)
C           RESULT - THE ELEMENT IN THE NEW DIAGONAL WITH LEAST VALUE
C                    OF ERROR
C
C           LIMEXP IS THE MAXIMUM NUMBER OF ELEMENTS THE EPSILON TABLE
C           CAN CONTAIN. IF THIS NUMBER IS REACHED, THE UPPER DIAGONAL
C           OF THE EPSILON TABLE IS DELETED.
C
      EPMACH = X02AJF()
      UFLOW = X02AMF()
      OFLOW = 1.0D+00/UFLOW
      NRES = NRES + 1
      ABSERR = OFLOW
      RESULT = EPSTAB(N)
      IF (N.LT.3) GO TO 200
      LIMEXP = 50
      EPSTAB(N+2) = EPSTAB(N)
      NEWELM = (N-1)/2
      EPSTAB(N) = OFLOW
      NUM = N
      K1 = N
      DO 80 I = 1, NEWELM
         K2 = K1 - 1
         K3 = K1 - 2
         RES = EPSTAB(K1+2)
         E0 = EPSTAB(K3)
         E1 = EPSTAB(K2)
         E2 = RES
         E1ABS = ABS(E1)
         DELTA2 = E2 - E1
         ERR2 = ABS(DELTA2)
         TOL2 = MAX(ABS(E2),E1ABS)*EPMACH
         DELTA3 = E1 - E0
         ERR3 = ABS(DELTA3)
         TOL3 = MAX(E1ABS,ABS(E0))*EPMACH
         IF (ERR2.GT.TOL2 .OR. ERR3.GT.TOL3) GO TO 20
C
C           IF E0, E1 AND E2 ARE EQUAL TO WITHIN MACHINE ACCURACY,
C           CONVERGENCE IS ASSUMED.
C           RESULT = E2
C           ABSERR = ABS(E1-E0)+ABS(E2-E1)
C
         RESULT = RES
         ABSERR = ERR2 + ERR3
C        ***JUMP OUT OF DO-LOOP
         GO TO 200
   20    E3 = EPSTAB(K1)
         EPSTAB(K1) = E1
         DELTA1 = E1 - E3
         ERR1 = ABS(DELTA1)
         TOL1 = MAX(E1ABS,ABS(E3))*EPMACH
C
C           IF TWO ELEMENTS ARE VERY CLOSE TO EACH OTHER, OMIT A PART
C           OF THE TABLE BY ADJUSTING THE VALUE OF N
C
         IF (ERR1.LE.TOL1 .OR. ERR2.LE.TOL2 .OR. ERR3.LE.TOL3)
     *       GO TO 40
         SS = 1.0D+00/DELTA1 + 1.0D+00/DELTA2 - 1.0D+00/DELTA3
         EPSINF = ABS(SS*E1)
C
C           TEST TO DETECT IRREGULAR BEHAVIOUR IN THE TABLE, AND
C           EVENTUALLY OMIT A PART OF THE TABLE ADJUSTING THE VALUE
C           OF N.
C
         IF (EPSINF.GT.1.0D-04) GO TO 60
   40    N = I + I - 1
C        ***JUMP OUT OF DO-LOOP
         GO TO 100
C
C           COMPUTE A NEW ELEMENT AND EVENTUALLY ADJUST THE VALUE OF
C           RESULT.
C
   60    RES = E1 + 1.0D+00/SS
         EPSTAB(K1) = RES
         K1 = K1 - 2
         ERROR = ERR2 + ABS(RES-E2) + ERR3
         IF (ERROR.GT.ABSERR) GO TO 80
         ABSERR = ERROR
         RESULT = RES
   80 CONTINUE
C
C           SHIFT THE TABLE.
C
  100 IF (N.EQ.LIMEXP) N = 2*(LIMEXP/2) - 1
      IB = 1
      IF ((NUM/2)*2.EQ.NUM) IB = 2
      IE = NEWELM + 1
      DO 120 I = 1, IE
         IB2 = IB + 2
         EPSTAB(IB) = EPSTAB(IB2)
         IB = IB2
  120 CONTINUE
      IF (NUM.EQ.N) GO TO 160
      INDX = NUM - N + 1
      DO 140 I = 1, N
         EPSTAB(I) = EPSTAB(INDX)
         INDX = INDX + 1
  140 CONTINUE
  160 IF (NRES.GE.4) GO TO 180
      RES3LA(NRES) = RESULT
      ABSERR = OFLOW
      GO TO 200
C
C           COMPUTE ERROR ESTIMATE
C
  180 ABSERR = ABS(RESULT-RES3LA(3)) + ABS(RESULT-RES3LA(2)) +
     *         ABS(RESULT-RES3LA(1))
      RES3LA(1) = RES3LA(2)
      RES3LA(2) = RES3LA(3)
      RES3LA(3) = RESULT
  200 ABSERR = MAX(ABSERR,0.5D+00*EPMACH*ABS(RESULT))
      RETURN
      END
      SUBROUTINE D01AJZ(F,A,B,RESULT,ABSERR,RESABS,RESASC)
C     MARK 13 RE-ISSUE. NAG COPYRIGHT 1988.
C     BASED ON QUADPACK ROUTINE  QK21.
C     ..................................................................
C
C           PURPOSE
C              TO COMPUTE I = INTEGRAL OF F OVER (A,B), WITH ERROR
C                             ESTIMATE
C                         J = INTEGRAL OF ABS(F) OVER (A,B)
C
C           PARAMETERS
C            ON ENTRY
C              F      - REAL
C                       FUNCTION SUBPROGRAM DEFINING THE INTEGRAND
C                       FUNCTION F(X). THE ACTUAL NAME FOR F NEEDS TO BE
C                       DECLARED E X T E R N A L IN THE CALLING PROGRAM.
C
C              A      - REAL
C                       LOWER LIMIT OF INTEGRATION
C
C              B      - REAL
C                       UPPER LIMIT OF INTEGRATION
C
C            ON RETURN
C              RESULT - REAL
C                       APPROXIMATION TO THE INTEGRAL I
C                       RESULT IS COMPUTED BY APPLYING THE 21-POINT
C                       KRONROD RULE (RESK) OBTAINED BY OPTIMAL ADDITION
C                       OF ABSCISSAE TO THE 10-POINT GAUSS RULE (RESG).
C
C              ABSERR - REAL
C                       ESTIMATE OF THE MODULUS OF THE ABSOLUTE ERROR,
C                       WHICH SHOULD NOT EXCEED ABS(I-RESULT)
C
C              RESABS - REAL
C                       APPROXIMATION TO THE INTEGRAL J
C
C              RESASC - REAL
C                       APPROXIMATION TO THE INTEGRAL OF ABS(F-I/(B-A))
C                       OVER (A,B)
C
C     ..................................................................
C
C           THE ABSCISSAE AND WEIGHTS ARE GIVEN FOR THE INTERVAL (-1,1).
C           BECAUSE OF SYMMETRY ONLY THE POSITIVE ABSCISSAE AND THEIR
C           CORRESPONDING WEIGHTS ARE GIVEN.
C
C           XGK    - ABSCISSAE OF THE 21-POINT KRONROD RULE
C                    XGK(2), XGK(4), ...  ABSCISSAE OF THE 10-POINT
C                    GAUSS RULE
C                    XGK(1), XGK(3), ...  ABSCISSAE WHICH ARE OPTIMALLY
C                    ADDED TO THE 10-POINT GAUSS RULE
C
C           WGK    - WEIGHTS OF THE 21-POINT KRONROD RULE
C
C           WG     - WEIGHTS OF THE 10-POINT GAUSS RULE
C
C     .. Scalar Arguments ..
      DOUBLE PRECISION  A, ABSERR, B, RESABS, RESASC, RESULT
C     .. Function Arguments ..
      DOUBLE PRECISION  F
      EXTERNAL          F
C     .. Local Scalars ..
      DOUBLE PRECISION  ABSC, CENTR, DHLGTH, EPMACH, FC, FSUM, FVAL1,
     *                  FVAL2, HLGTH, OFLOW, RESG, RESK, RESKH, UFLOW
      INTEGER           J, JTW, JTWM1
C     .. Local Arrays ..
      DOUBLE PRECISION  FV1(10), FV2(10), WG(5), WGK(11), XGK(11)
C     .. External Functions ..
      DOUBLE PRECISION  X02AJF, X02AMF
      EXTERNAL          X02AJF, X02AMF
C     .. Intrinsic Functions ..
      INTRINSIC         ABS, MAX, MIN
C     .. Data statements ..
      DATA              WG(1)/0.066671344308688137593568809893332D+00/,
     *                  WG(2)/0.149451349150580593145776339657697D+00/,
     *                  WG(3)/0.219086362515982043995534934228163D+00/,
     *                  WG(4)/0.269266719309996355091226921569469D+00/,
     *                  WG(5)/0.295524224714752870173892994651338D+00/
      DATA              XGK(1)/0.995657163025808080735527280689003D+00/,
     *                  XGK(2)/0.973906528517171720077964012084452D+00/,
     *                  XGK(3)/0.930157491355708226001207180059508D+00/,
     *                  XGK(4)/0.865063366688984510732096688423493D+00/,
     *                  XGK(5)/0.780817726586416897063717578345042D+00/,
     *                  XGK(6)/0.679409568299024406234327365114874D+00/,
     *                  XGK(7)/0.562757134668604683339000099272694D+00/,
     *                  XGK(8)/0.433395394129247190799265943165784D+00/,
     *                  XGK(9)/0.294392862701460198131126603103866D+00/,
     *                  XGK(10)/0.148874338981631210884826001129720D+00/
     *                  , XGK(11)/
     *                  0.000000000000000000000000000000000D+00/
      DATA              WGK(1)/0.011694638867371874278064396062192D+00/,
     *                  WGK(2)/0.032558162307964727478818972459390D+00/,
     *                  WGK(3)/0.054755896574351996031381300244580D+00/,
     *                  WGK(4)/0.075039674810919952767043140916190D+00/,
     *                  WGK(5)/0.093125454583697605535065465083366D+00/,
     *                  WGK(6)/0.109387158802297641899210590325805D+00/,
     *                  WGK(7)/0.123491976262065851077958109831074D+00/,
     *                  WGK(8)/0.134709217311473325928054001771707D+00/,
     *                  WGK(9)/0.142775938577060080797094273138717D+00/,
     *                  WGK(10)/0.147739104901338491374841515972068D+00/
     *                  , WGK(11)/
     *                  0.149445554002916905664936468389821D+00/
C     .. Executable Statements ..
C
C
C           LIST OF MAJOR VARIABLES
C           -----------------------
C
C           CENTR  - MID POINT OF THE INTERVAL
C           HLGTH  - HALF-LENGTH OF THE INTERVAL
C           ABSC   - ABSCISSA
C           FVAL*  - FUNCTION VALUE
C           RESG   - RESULT OF THE 10-POINT GAUSS FORMULA
C           RESK   - RESULT OF THE 21-POINT KRONROD FORMULA
C           RESKH  - APPROXIMATION TO THE MEAN VALUE OF F OVER (A,B),
C                    I.E. TO I/(B-A)
C
      EPMACH = X02AJF()
      UFLOW = X02AMF()
      OFLOW = 1.0D+00/UFLOW
      CENTR = 5.0D-01*(A+B)
      HLGTH = 5.0D-01*(B-A)
      DHLGTH = ABS(HLGTH)
C
C           COMPUTE THE 21-POINT KRONROD APPROXIMATION TO THE
C           INTEGRAL, AND ESTIMATE THE ABSOLUTE ERROR.
C
      RESG = 0.0D+00
      FC = F(CENTR)
      RESK = WGK(11)*FC
      RESABS = ABS(RESK)
      DO 20 J = 1, 5
         JTW = 2*J
         ABSC = HLGTH*XGK(JTW)
         FVAL1 = F(CENTR-ABSC)
         FVAL2 = F(CENTR+ABSC)
         FV1(JTW) = FVAL1
         FV2(JTW) = FVAL2
         FSUM = FVAL1 + FVAL2
         RESG = RESG + WG(J)*FSUM
         RESK = RESK + WGK(JTW)*FSUM
         RESABS = RESABS + WGK(JTW)*(ABS(FVAL1)+ABS(FVAL2))
   20 CONTINUE
      DO 40 J = 1, 5
         JTWM1 = 2*J - 1
         ABSC = HLGTH*XGK(JTWM1)
         FVAL1 = F(CENTR-ABSC)
         FVAL2 = F(CENTR+ABSC)
         FV1(JTWM1) = FVAL1
         FV2(JTWM1) = FVAL2
         FSUM = FVAL1 + FVAL2
         RESK = RESK + WGK(JTWM1)*FSUM
         RESABS = RESABS + WGK(JTWM1)*(ABS(FVAL1)+ABS(FVAL2))
   40 CONTINUE
      RESKH = RESK*5.0D-01
      RESASC = WGK(11)*ABS(FC-RESKH)
      DO 60 J = 1, 10
         RESASC = RESASC + WGK(J)*(ABS(FV1(J)-RESKH)+ABS(FV2(J)-RESKH))
   60 CONTINUE
      RESULT = RESK*HLGTH
      RESABS = RESABS*DHLGTH
      RESASC = RESASC*DHLGTH
      ABSERR = ABS((RESK-RESG)*HLGTH)
      IF (RESASC.NE.0.0D+00 .AND. ABSERR.NE.0.0D+00)
     *    ABSERR = RESASC*MIN(1.0D+00,(2.0D+02*ABSERR/RESASC)**1.5D+00)
      IF (RESABS.GT.UFLOW/(5.0D+01*EPMACH))
     *    ABSERR = MAX((EPMACH*5.0D+01)*RESABS,ABSERR)
      RETURN
      END

      SUBROUTINE C05AXF(X,FX,TOL,IR,SCALE,C,IND,IFAIL)
C     MARK 8 RELEASE. NAG COPYRIGHT 1979.
C     MARK 9 REVISED. IER-301 (SEP 1981).
C     MARK 11.5(F77) REVISED. (SEPT 1985.)
C     MARK 13 REVISED. USE OF MARK 12 X02 FUNCTIONS (APR 1988).
C     USES METHOD OF OF SWIFT AND LINDFIELD,
C     C.J.VOL 21. MINK=C(1),MAXK=C(2).
C     .. Parameters ..
      CHARACTER*6       SRNAME
      PARAMETER         (SRNAME='C05AXF')
C     .. Scalar Arguments ..
      DOUBLE PRECISION  FX, SCALE, TOL, X
      INTEGER           IFAIL, IND, IR
C     .. Array Arguments ..
      DOUBLE PRECISION  C(26)
C     .. Local Scalars ..
      DOUBLE PRECISION  AB, OLDTH, REL, SE, SF
      INTEGER           I
C     .. Local Arrays ..
      CHARACTER*1       P01REC(1)
C     .. External Functions ..
      DOUBLE PRECISION  X02AJF
      INTEGER           P01ABF
      EXTERNAL          X02AJF, P01ABF
C     .. Intrinsic Functions ..
      INTRINSIC         ABS, MAX, SQRT
C     .. Executable Statements ..
      IF (TOL.LE.0.0D0) GO TO 440
      IF (X+SCALE.EQ.X) GO TO 480
      IF (IND.LT.-1 .OR. IND.GT.4) GO TO 460
      IF (IR.LT.0 .OR. IR.GT.2) GO TO 440
      AB = 1.0D0
      REL = 1.0D0
      IF (IR.EQ.1) REL = 0.0D0
      IF (IR.EQ.2) AB = 0.0D0
      I = IND + 2
      GO TO (40,460,20,40,80,260) I
   20 IND = 2
      RETURN
   40 IF (FX.EQ.0.0D0) GO TO 580
      C(1) = 3.0D0
      C(2) = 8.0D0
      C(4) = 1.0D0
      C(6) = 1.0D0
      C(7) = 0.5D0
      C(8) = FX
      C(22) = X
      C(25) = X02AJF()
      C(19) = SQRT(C(25))
      C(5) = 1.0D0 - 0.5D0*C(19)
      C(23) = C(19)*SCALE
      C(20) = 0.D0
   60 X = C(22) + C(23)
      IF (X.EQ.C(22)) GO TO 100
      IND = 3
      RETURN
   80 IF (FX.EQ.0.0D0) GO TO 580
      C(24) = FX - C(8)
      X = C(22)
      IF (ABS(C(24)).GT.100.0D0*C(25)*MAX(ABS(FX),ABS(C(8))))
     *    GO TO 120
  100 C(23) = 10.0D0*C(23)
      IF (ABS(C(23)).GT.ABS(SCALE)) GO TO 480
      GO TO 60
  120 C(12) = C(23)/C(24)
C
C     CONTINUATION OUTER LOOP
C
  140 C(14) = SQRT(TOL)
      IF (C(5).EQ.0.0D0) C(14) = TOL
      C(3) = 0.0D0
      C(9) = X
      C(13) = C(12)
      C(15) = C(6) - C(5)
      IF (C(15).LT.100.0D0*C(25)) GO TO 500
      C(21) = C(8)*C(5)
      C(10) = C(15)*C(8)
      C(11) = C(10)
      C(26) = 0.0D0
C
C     CONTINUATION INNER LOOP
C
  160 C(17) = C(12)*C(10)
      SF = C(26)
      C(26) = 0.0D0
      IF (ABS(C(17)).LT.C(14)*MAX(REL*ABS(X),AB)) C(26) = SF + 1.0D0
      IF (C(26).GT.0.0D0 .AND. ABS(C(10)).LT.ABS(C(11)) .AND. C(3)
     *    .GT.1.5D0) GO TO 280
      IF (ABS(C(3)-C(2)).GT.0.5D0) GO TO 240
      IF (C(26).GT.C(2)-2.5D0) GO TO 280
      SE = (C(10)+C(21))/C(8)
      IF (SE.GT.C(5) .AND. SE.LT.C(6)) GO TO 200
      C(12) = C(13)
      C(7) = 0.5D0*C(7)
      IF (C(6)-C(5).GT.100.0D0*C(25)) GO TO 180
      IF (C(4).LT.1.5D0) GO TO 500
      GO TO 400
  180 C(5) = 0.5D0*(C(5)+C(6))
      X = C(9)
      GO TO 140
  200 C(21) = SE*C(8)
      C(15) = C(6) - SE
      IF (C(5).NE.0.0D0) GO TO 220
      IF (C(15).LT.100.0D0*C(25)) GO TO 500
  220 C(5) = SE
      GO TO 280
  240 X = X - C(17)
      IND = 4
      RETURN
  260 IF (FX.EQ.0.0D0) GO TO 580
      SE = FX - C(21)
      SF = SE - C(10)
      IF (ABS(SF).LE.2.D0*C(25)*MAX(ABS(SE),ABS(C(10)),ABS(C(21))))
     *    GO TO 280
      C(10) = SE
      C(3) = C(3) + 1.0D0
      IF (SF.EQ.0.0D0) GO TO 160
      C(12) = -C(17)/SF
      GO TO 160
C
C     SUCCESSFUL INNER LOOP
C
  280 IF (C(5).EQ.0.0D0) GO TO 580
      C(17) = C(9) - X
      OLDTH = C(6)
      C(6) = C(5)
      IF (ABS(C(4)-1.0D0).GT.0.5D0) GO TO 300
      C(5) = 1.0D0 - C(19)
      GO TO 420
  300 SF = C(17)/C(15)
      SE = (C(18)/C(16)-SF)/(C(15)+C(16))
      IF (ABS(SF)*C(19).GT.ABS(C(15)) .OR. SE.EQ.0.D0 .OR. ABS(SE)*C(19)
     *    .GT.ABS(C(15)+C(16))) GO TO 320
      IF (C(3).LE.C(1)+0.5D0 .AND. C(4).GT.2.5D0) C(7) = 2.0D0*C(7)
      IF (ABS(SE)*C(5).GT.C(7)*ABS(SF-SE*C(15))) GO TO 360
      C(5) = 0.D0
      GO TO 420
  320 IF (C(5).LE.0.9D0) GO TO 340
      C(5) = 0.9D0
      GO TO 380
  340 C(5) = C(5)*0.5D0
      GO TO 380
  360 C(5) = C(5) - C(7)*ABS(SF/SE-C(15))
      IF (C(5).LT.0.0D0) C(5) = 0.0D0
      IF (C(5).EQ.0.0D0) GO TO 420
  380 CONTINUE
      IF (OLDTH-C(5).GE.100.0D0*C(25) .AND. C(5).GE.C(19)) GO TO 420
  400 CONTINUE
      IF (C(4).GT.2.5D0) GO TO 500
      C(19) = 0.1D0*C(19)
      IF (C(19).LT.100.0D0*C(25)) GO TO 540
      C(6) = 1.0D0
      C(5) = 1.0D0 - 0.5D0*C(19)
      C(20) = 0.0D0
      X = C(9)
      C(4) = 1.0D0
      C(7) = 0.5D0
      GO TO 140
  420 C(16) = C(15)
      C(18) = C(17)
      C(4) = C(4) + 1.0D0
      C(20) = 1.0D0
      IF (C(5).EQ.0.0D0) C(20) = 2.0D0
      GO TO 140
C     INPUT ERROR
  440 I = 1
      GO TO 600
C     WRONG IND ON ENTRY
  460 I = 2
      GO TO 600
C     WRONG SCALE
  480 I = 3
      GO TO 600
C     SINGULARITY ON CONTINUATION PATH
  500 IF (C(20).NE.1.0D0) GO TO 520
      I = 4
      GO TO 600
C     CANNOT GET STARTED
  520 IF (C(20).NE.0.0D0) GO TO 560
  540 I = 5
      GO TO 600
C     CANNOT FINISH
  560 I = 6
      GO TO 600
C     FINISHED
  580 I = 0
  600 IND = 0
      IFAIL = P01ABF(IFAIL,I,SRNAME,0,P01REC)
      RETURN
      END

      SUBROUTINE C05ADF(A,B,EPS,ETA,F,X,IFAIL)
C     MARK 8 RELEASE. NAG COPYRIGHT 1979.
C     MARK 10C REVISED. IER-422 (JUL 1983).
C     MARK 11.5(F77) REVISED. (SEPT 1985.)
C     DRIVER FOR C05AZF
C     .. Parameters ..
      CHARACTER*6       SRNAME
      PARAMETER         (SRNAME='C05ADF')
C     .. Scalar Arguments ..
      DOUBLE PRECISION  A, B, EPS, ETA, X
      INTEGER           IFAIL
C     .. Function Arguments ..
      DOUBLE PRECISION  F
      EXTERNAL          F
C     .. Local Scalars ..
      DOUBLE PRECISION  FX, Y
      INTEGER           IFAIL1, IND, IR
C     .. Local Arrays ..
      DOUBLE PRECISION  C(17)
      CHARACTER*1       P01REC(1)
C     .. External Functions ..
      INTEGER           P01ABF
      EXTERNAL          P01ABF
C     .. External Subroutines ..
      EXTERNAL          C05AZF
C     .. Intrinsic Functions ..
      INTRINSIC         ABS, SIGN
C     .. Executable Statements ..
      IFAIL1 = 1
C     INPUT ERROR
      IF (A.EQ.B .OR. EPS.LE.0.D0) GO TO 120
      X = A
      FX = F(X)
      IFAIL1 = 0
C     ZERO AT INITIAL POINT
      IF (ABS(FX).LT.ETA .OR. FX.EQ.0.D0) GO TO 120
      Y = X
      C(1) = FX
      X = B
      FX = F(X)
C     ZERO AT INITIAL POINT
      IF (ABS(FX).LT.ETA .OR. FX.EQ.0.D0) GO TO 120
      IFAIL1 = 1
C     NO ROOT IN RANGE
      IF (SIGN(1.D0,FX).EQ.SIGN(1.D0,C(1))) GO TO 120
      IR = 1
      IND = -1
   20 CALL C05AZF(X,Y,FX,EPS,IR,C,IND,IFAIL1)
      IF (IND.EQ.0) GO TO 40
      FX = F(X)
      IF (ABS(FX).GE.ETA .AND. FX.NE.0.D0) GO TO 20
C     ZERO HIT EXACTLY
      IFAIL1 = 0
      GO TO 120
   40 IF (IFAIL1.EQ.0) GO TO 120
      GO TO (60,60,60,100,80) IFAIL1
C     IMPOSSIBLE EXIT
   60 IFAIL1 = 4
      GO TO 120
C     TOO MUCH ACCURACY REQUESTED
   80 IFAIL1 = 2
      GO TO 120
C     PROBABLY A POLE
  100 IFAIL1 = 3
  120 IFAIL = P01ABF(IFAIL,IFAIL1,SRNAME,0,P01REC)
      RETURN
      END

      SUBROUTINE C05AZF(X,Y,FX,TOLX,IR,C,IND,IFAIL)
C     MARK 8 RE-ISSUE. NAG COPYRIGHT 1979.
C     MARK 11.5(F77) REVISED. (SEPT 1985.)
C     MARK 12A REVISED. IER-496 (AUG 1986).
C     MARK 13 REVISED. USE OF MARK 12 X02 FUNCTIONS (APR 1988).
C     .. Parameters ..
      CHARACTER*6       SRNAME
      PARAMETER         (SRNAME='C05AZF')
C     .. Scalar Arguments ..
      DOUBLE PRECISION  FX, TOLX, X, Y
      INTEGER           IFAIL, IND, IR
C     .. Array Arguments ..
      DOUBLE PRECISION  C(17)
C     .. Local Scalars ..
      DOUBLE PRECISION  AB, DIFF, DIFF1, DIFF2, REL, RMAX, TOL, TOL1
      INTEGER           I
      LOGICAL           T
C     .. Local Arrays ..
      CHARACTER*1       P01REC(1)
C     .. External Functions ..
      DOUBLE PRECISION  X02AJF, X02AKF
      INTEGER           P01ABF
      EXTERNAL          X02AJF, X02AKF, P01ABF
C     .. Intrinsic Functions ..
      INTRINSIC         ABS, MAX, SIGN, DBLE, SQRT, INT
C     .. Executable Statements ..
      I = 0
      IF ((IND.GT.0 .AND. IND.LE.4) .OR. IND.EQ.-1) GO TO 20
C     USER NOT CHECKED IND OR CHANGED IT
      I = 2
      IND = 0
      GO TO 640
   20 IF (TOLX.GT.0.D0 .AND. (IR.EQ.0 .OR. IR.EQ.1 .OR. IR.EQ.2))
     *    GO TO 40
      I = 3
      IND = 0
      GO TO 640
   40 REL = 1.D0
      AB = 1.D0
      IF (IR.EQ.1) REL = 0.D0
      IF (IR.EQ.2) AB = 0.D0
      IF (IND.EQ.-1) GO TO 80
      GO TO (60,100,180,480) IND
   60 C(3) = X
      IND = 2
      RETURN
   80 C(3) = X
  100 IF (FX.NE.0.D0) GO TO 140
  120 Y = X
      IND = 0
      I = 0
      GO TO 640
  140 C(4) = FX
      C(15) = ABS(FX)
      C(16) = 0.D0
      X = Y
      Y = C(3)
      C(2) = C(4)
      C(5) = X
      IF (IND.EQ.-1) GO TO 160
      IND = 3
      RETURN
  160 FX = C(1)
      IND = 3
  180 IF (FX.EQ.0.D0) GO TO 120
      IF (SIGN(1.D0,FX).NE.SIGN(1.D0,C(2))) GO TO 200
      IND = 0
      I = 1
      GO TO 640
  200 C(6) = FX
      C(13) = SQRT(X02AJF())
      C(15) = MAX(C(15),ABS(FX))
      C(14) = X02AKF()
      C(16) = 0.0D0
  220 C(1) = C(5)
      C(2) = C(6)
      C(17) = 0.D0
  240 IF (ABS(C(2)).GE.ABS(C(4))) GO TO 280
      IF (C(1).EQ.C(5)) GO TO 260
      C(7) = C(5)
      C(8) = C(6)
  260 C(5) = C(3)
      C(6) = C(4)
      X = C(1)
      C(3) = X
      C(4) = C(2)
      C(1) = C(5)
      C(2) = C(6)
  280 TOL = 0.5D0*TOLX*MAX(AB,REL*ABS(C(3)))
      TOL1 = 2.0D0*X02AJF()*MAX(AB,REL*ABS(C(3)))
      DIFF2 = 0.5D0*(C(1)-C(3))
      C(12) = DIFF2
      DIFF2 = DIFF2 + C(3)
      IF (C(12).EQ.0.D0) GO TO 340
      IF (ABS(C(12)).LE.TOL) GO TO 580
      IF (ABS(C(12)).LE.TOL1) GO TO 340
      IF (C(17).LT.2.5D0) GO TO 300
      C(11) = C(12)
      GO TO 460
  300 TOL = TOL*SIGN(1.D0,C(12))
      DIFF1 = (C(3)-C(5))*C(4)
      IF (C(17).GT.1.5D0) GO TO 320
      DIFF = C(6) - C(4)
      GO TO 380
  320 IF (C(7).NE.C(3) .AND. C(7).NE.C(5)) GO TO 360
  340 IND = 0
      I = 5
      GO TO 640
  360 C(9) = (C(8)-C(4))/(C(7)-C(3))
      C(10) = (C(8)-C(6))/(C(7)-C(5))
      DIFF1 = C(10)*DIFF1
      DIFF = C(9)*C(6) - C(10)*C(4)
  380 IF (DIFF1.GE.0.D0) GO TO 400
      DIFF1 = -DIFF1
      DIFF = -DIFF
  400 IF (ABS(DIFF1).GT.C(14) .AND. DIFF1.GT.DIFF*TOL) GO TO 420
      C(11) = TOL
      GO TO 460
  420 IF (DIFF1.GE.C(12)*DIFF) GO TO 440
      C(11) = DIFF1/DIFF
      GO TO 460
  440 C(11) = C(12)
  460 C(7) = C(5)
      C(8) = C(6)
      C(5) = C(3)
      C(6) = C(4)
      C(3) = C(3) + C(11)
      X = C(3)
      Y = C(1)
      IND = 4
      RETURN
  480 IF (FX.EQ.0.D0) GO TO 120
      C(4) = FX
      RMAX = ABS(FX)
      IF (C(13)*RMAX.LE.C(15)) GO TO 500
      IF (C(16).EQ.1.D0) C(16) = -1.D0
      IF (C(16).EQ.0.D0) C(16) = 1.D0
      GO TO 520
  500 C(16) = 0.D0
  520 IF (C(2).GE.0.D0) GO TO 540
      T = C(4) .LE. 0.D0
      GO TO 560
  540 T = C(4) .GE. 0.D0
  560 IF (T) GO TO 220
      I = INT(C(17)+0.1D0)
      I = I + 1
      IF (C(11).EQ.C(12)) I = 0
      C(17) = DBLE(I)
      GO TO 240
  580 IF (C(16).GE.0.D0) GO TO 600
      I = 4
      GO TO 620
  600 Y = C(1)
      I = 0
  620 IND = 0
  640 IFAIL = P01ABF(IFAIL,I,SRNAME,0,P01REC)
      RETURN
      END

      DOUBLE PRECISION FUNCTION X02AKF()
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C
C     RETURNS  B**(EMIN-1)  (THE SMALLEST POSITIVE MODEL NUMBER)
C
      DOUBLE PRECISION X02CON
      DATA X02CON /2.22507385850721D-308 /
C     .. Executable Statements ..
      X02AKF = X02CON
      RETURN
      END


